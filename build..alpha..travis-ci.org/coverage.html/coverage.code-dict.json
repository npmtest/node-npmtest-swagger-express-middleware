{"/home/travis/build/npmtest/node-npmtest-swagger-express-middleware/test.js":"/* istanbul instrument in package npmtest_swagger_express_middleware */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - init-before\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        switch (local.modeJs) {\n        // re-init local from window.local\n        case 'browser':\n            local = local.global.utility2.objectSetDefault(\n                local.global.utility2_rollup || local.global.local,\n                local.global.utility2\n            );\n            break;\n        // re-init local from example.js\n        case 'node':\n            local = (local.global.utility2_rollup || require('utility2'))\n                .requireReadme();\n            break;\n        }\n        // export local\n        local.global.local = local;\n    }());\n\n\n\n    // run shared js-env code - function\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - function\n    case 'browser':\n        break;\n\n\n\n    // run node js-env code - function\n    case 'node':\n        break;\n    }\n\n\n\n    // run shared js-env code - init-after\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - init-after\n    case 'browser':\n        local.testCase_browser_nullCase = local.testCase_browser_nullCase || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test browsers's null-case handling-behavior-behavior\n         */\n            onError(null, options);\n        };\n\n        // run tests\n        local.nop(local.modeTest &&\n            document.querySelector('#testRunButton1') &&\n            document.querySelector('#testRunButton1').click());\n        break;\n\n\n\n    // run node js-env code - init-after\n    /* istanbul ignore next */\n    case 'node':\n        local.testCase_buildApidoc_default = local.testCase_buildApidoc_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApidoc's default handling-behavior-behavior\n         */\n            options = { modulePathList: module.paths };\n            local.buildApidoc(options, onError);\n        };\n\n        local.testCase_buildApp_default = local.testCase_buildApp_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApp's default handling-behavior-behavior\n         */\n            local.testCase_buildReadme_default(options, local.onErrorThrow);\n            local.testCase_buildLib_default(options, local.onErrorThrow);\n            local.testCase_buildTest_default(options, local.onErrorThrow);\n            local.testCase_buildCustomOrg_default(options, local.onErrorThrow);\n            options = [];\n            local.buildApp(options, onError);\n        };\n\n        local.testCase_buildCustomOrg_default = local.testCase_buildCustomOrg_default ||\n            function (options, onError) {\n            /*\n             * this function will test buildCustomOrg's default handling-behavior\n             */\n                options = {};\n                local.buildCustomOrg(options, onError);\n            };\n\n        local.testCase_buildLib_default = local.testCase_buildLib_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildLib's default handling-behavior\n         */\n            options = {};\n            local.buildLib(options, onError);\n        };\n\n        local.testCase_buildReadme_default = local.testCase_buildReadme_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildReadme's default handling-behavior-behavior\n         */\n            options = {};\n            local.buildReadme(options, onError);\n        };\n\n        local.testCase_buildTest_default = local.testCase_buildTest_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildTest's default handling-behavior\n         */\n            options = {};\n            local.buildTest(options, onError);\n        };\n\n        local.testCase_webpage_default = local.testCase_webpage_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test webpage's default handling-behavior\n         */\n            options = { modeCoverageMerge: true, url: local.serverLocalHost + '?modeTest=1' };\n            local.browserTest(options, onError);\n        };\n\n        // run test-server\n        local.testRunServer(local);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-swagger-express-middleware/lib.npmtest_swagger_express_middleware.js":"/* istanbul instrument in package npmtest_swagger_express_middleware */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - init-before\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || local;\n        // init lib\n        local.local = local.npmtest_swagger_express_middleware = local;\n        // init exports\n        if (local.modeJs === 'browser') {\n            local.global.utility2_npmtest_swagger_express_middleware = local;\n        } else {\n            module.exports = local;\n            module.exports.__dirname = __dirname;\n            module.exports.module = module;\n        }\n    }());\n}());\n","/home/travis/build/npmtest/node-npmtest-swagger-express-middleware/example.js":"/*\nexample.js\n\nquickstart example\n\ninstruction\n    1. save this script as example.js\n    2. run the shell command:\n        $ npm install npmtest-swagger-express-middleware && PORT=8081 node example.js\n    3. play with the browser-demo on http://127.0.0.1:8081\n*/\n\n\n\n/* istanbul instrument in package npmtest_swagger_express_middleware */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - init-before\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || (local.modeJs === 'browser'\n            ? local.global.utility2_npmtest_swagger_express_middleware\n            : global.utility2_moduleExports);\n        // export local\n        local.global.local = local;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // init-after\n    // run browser js-env code - init-after\n    /* istanbul ignore next */\n    case 'browser':\n        local.testRunBrowser = function (event) {\n            if (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('onreset'))) {\n                // reset output\n                Array.from(\n                    document.querySelectorAll('body > .resettable')\n                ).forEach(function (element) {\n                    switch (element.tagName) {\n                    case 'INPUT':\n                    case 'TEXTAREA':\n                        element.value = '';\n                        break;\n                    default:\n                        element.textContent = '';\n                    }\n                });\n            }\n            switch (event && event.currentTarget && event.currentTarget.id) {\n            case 'testRunButton1':\n                // show tests\n                if (document.querySelector('#testReportDiv1').style.display === 'none') {\n                    document.querySelector('#testReportDiv1').style.display = 'block';\n                    document.querySelector('#testRunButton1').textContent =\n                        'hide internal test';\n                    local.modeTest = true;\n                    local.testRunDefault(local);\n                // hide tests\n                } else {\n                    document.querySelector('#testReportDiv1').style.display = 'none';\n                    document.querySelector('#testRunButton1').textContent = 'run internal test';\n                }\n                break;\n            // custom-case\n            default:\n                break;\n            }\n            if (document.querySelector('#inputTextareaEval1') && (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('oneval')))) {\n                // try to eval input-code\n                try {\n                    /*jslint evil: true*/\n                    eval(document.querySelector('#inputTextareaEval1').value);\n                } catch (errorCaught) {\n                    console.error(errorCaught);\n                }\n            }\n        };\n        // log stderr and stdout to #outputTextareaStdout1\n        ['error', 'log'].forEach(function (key) {\n            console[key + '_original'] = console[key];\n            console[key] = function () {\n                var element;\n                console[key + '_original'].apply(console, arguments);\n                element = document.querySelector('#outputTextareaStdout1');\n                if (!element) {\n                    return;\n                }\n                // append text to #outputTextareaStdout1\n                element.value += Array.from(arguments).map(function (arg) {\n                    return typeof arg === 'string'\n                        ? arg\n                        : JSON.stringify(arg, null, 4);\n                }).join(' ') + '\\n';\n                // scroll textarea to bottom\n                element.scrollTop = element.scrollHeight;\n            };\n        });\n        // init event-handling\n        ['change', 'click', 'keyup'].forEach(function (event) {\n            Array.from(document.querySelectorAll('.on' + event)).forEach(function (element) {\n                element.addEventListener(event, local.testRunBrowser);\n            });\n        });\n        // run tests\n        local.testRunBrowser();\n        break;\n\n\n\n    // run node js-env code - init-after\n    /* istanbul ignore next */\n    case 'node':\n        // export local\n        module.exports = local;\n        // require modules\n        local.fs = require('fs');\n        local.http = require('http');\n        local.url = require('url');\n        // init assets\n        local.assetsDict = local.assetsDict || {};\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.index.template.html'] = '\\\n<!doctype html>\\n\\\n<html lang=\"en\">\\n\\\n<head>\\n\\\n<meta charset=\"UTF-8\">\\n\\\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\\n\\\n<title>{{env.npm_package_name}} (v{{env.npm_package_version}})</title>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n    box-sizing: false,\\n\\\n    universal-selector: false\\n\\\n*/\\n\\\n* {\\n\\\n    box-sizing: border-box;\\n\\\n}\\n\\\nbody {\\n\\\n    background: #dde;\\n\\\n    font-family: Arial, Helvetica, sans-serif;\\n\\\n    margin: 2rem;\\n\\\n}\\n\\\nbody > * {\\n\\\n    margin-bottom: 1rem;\\n\\\n}\\n\\\n.utility2FooterDiv {\\n\\\n    margin-top: 20px;\\n\\\n    text-align: center;\\n\\\n}\\n\\\n</style>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n*/\\n\\\ntextarea {\\n\\\n    font-family: monospace;\\n\\\n    height: 10rem;\\n\\\n    width: 100%;\\n\\\n}\\n\\\ntextarea[readonly] {\\n\\\n    background: #ddd;\\n\\\n}\\n\\\n</style>\\n\\\n</head>\\n\\\n<body>\\n\\\n<!-- utility2-comment\\n\\\n<div id=\"ajaxProgressDiv1\" style=\"background: #d00; height: 2px; left: 0; margin: 0; padding: 0; position: fixed; top: 0; transition: background 0.5s, width 1.5s; width: 25%;\"></div>\\n\\\nutility2-comment -->\\n\\\n<h1>\\n\\\n<!-- utility2-comment\\n\\\n    <a\\n\\\n        {{#if env.npm_package_homepage}}\\n\\\n        href=\"{{env.npm_package_homepage}}\"\\n\\\n        {{/if env.npm_package_homepage}}\\n\\\n        target=\"_blank\"\\n\\\n    >\\n\\\nutility2-comment -->\\n\\\n        {{env.npm_package_name}} (v{{env.npm_package_version}})\\n\\\n<!-- utility2-comment\\n\\\n    </a>\\n\\\nutility2-comment -->\\n\\\n</h1>\\n\\\n<h3>{{env.npm_package_description}}</h3>\\n\\\n<!-- utility2-comment\\n\\\n<h4><a download href=\"assets.app.js\">download standalone app</a></h4>\\n\\\n<button class=\"onclick onreset\" id=\"testRunButton1\">run internal test</button><br>\\n\\\n<div id=\"testReportDiv1\" style=\"display: none;\"></div>\\n\\\nutility2-comment -->\\n\\\n\\n\\\n\\n\\\n\\n\\\n<label>stderr and stdout</label>\\n\\\n<textarea class=\"resettable\" id=\"outputTextareaStdout1\" readonly></textarea>\\n\\\n<!-- utility2-comment\\n\\\n{{#if isRollup}}\\n\\\n<script src=\"assets.app.js\"></script>\\n\\\n{{#unless isRollup}}\\n\\\nutility2-comment -->\\n\\\n<script src=\"assets.utility2.rollup.js\"></script>\\n\\\n<script src=\"jsonp.utility2._stateInit?callback=window.utility2._stateInit\"></script>\\n\\\n<script src=\"assets.npmtest_swagger_express_middleware.rollup.js\"></script>\\n\\\n<script src=\"assets.example.js\"></script>\\n\\\n<script src=\"assets.test.js\"></script>\\n\\\n<!-- utility2-comment\\n\\\n{{/if isRollup}}\\n\\\nutility2-comment -->\\n\\\n<div class=\"utility2FooterDiv\">\\n\\\n    [ this app was created with\\n\\\n    <a href=\"https://github.com/kaizhu256/node-utility2\" target=\"_blank\">utility2</a>\\n\\\n    ]\\n\\\n</div>\\n\\\n</body>\\n\\\n</html>\\n\\\n';\n        /* jslint-ignore-end */\n        if (local.templateRender) {\n            local.assetsDict['/'] = local.templateRender(\n                local.assetsDict['/assets.index.template.html'],\n                {\n                    env: local.objectSetDefault(local.env, {\n                        npm_package_description: 'the greatest app in the world!',\n                        npm_package_name: 'my-app',\n                        npm_package_nameAlias: 'my_app',\n                        npm_package_version: '0.0.1'\n                    })\n                }\n            );\n        } else {\n            local.assetsDict['/'] = local.assetsDict['/assets.index.template.html']\n                .replace((/\\{\\{env\\.(\\w+?)\\}\\}/g), function (match0, match1) {\n                    // jslint-hack\n                    String(match0);\n                    switch (match1) {\n                    case 'npm_package_description':\n                        return 'the greatest app in the world!';\n                    case 'npm_package_name':\n                        return 'my-app';\n                    case 'npm_package_nameAlias':\n                        return 'my_app';\n                    case 'npm_package_version':\n                        return '0.0.1';\n                    }\n                });\n        }\n        // run the cli\n        if (local.global.utility2_rollup || module !== require.main) {\n            break;\n        }\n        local.assetsDict['/assets.example.js'] =\n            local.assetsDict['/assets.example.js'] ||\n            local.fs.readFileSync(__filename, 'utf8');\n        // bug-workaround - long $npm_package_buildCustomOrg\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.npmtest_swagger_express_middleware.rollup.js'] =\n            local.assetsDict['/assets.npmtest_swagger_express_middleware.rollup.js'] ||\n            local.fs.readFileSync(\n                local.npmtest_swagger_express_middleware.__dirname + '/lib.npmtest_swagger_express_middleware.js',\n                'utf8'\n            ).replace((/^#!/), '//');\n        /* jslint-ignore-end */\n        local.assetsDict['/favicon.ico'] = local.assetsDict['/favicon.ico'] || '';\n        // if $npm_config_timeout_exit exists,\n        // then exit this process after $npm_config_timeout_exit ms\n        if (Number(process.env.npm_config_timeout_exit)) {\n            setTimeout(process.exit, Number(process.env.npm_config_timeout_exit));\n        }\n        // start server\n        if (local.global.utility2_serverHttp1) {\n            break;\n        }\n        process.env.PORT = process.env.PORT || '8081';\n        console.error('server starting on port ' + process.env.PORT);\n        local.http.createServer(function (request, response) {\n            request.urlParsed = local.url.parse(request.url);\n            if (local.assetsDict[request.urlParsed.pathname] !== undefined) {\n                response.end(local.assetsDict[request.urlParsed.pathname]);\n                return;\n            }\n            response.statusCode = 404;\n            response.end();\n        }).listen(process.env.PORT);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-swagger-express-middleware/node_modules/swagger-express-middleware/lib/index.js":"'use strict';\n\nmodule.exports = createMiddleware;\nmodule.exports.Middleware = require('./middleware');\nmodule.exports.Resource = require('./data-store/resource');\nmodule.exports.DataStore = require('./data-store');\nmodule.exports.MemoryDataStore = require('./data-store/memory-data-store');\nmodule.exports.FileDataStore = require('./data-store/file-data-store');\n\nvar util = require('./helpers/util');\n\n/**\n * Creates Express middleware for the given Swagger API.\n *\n * @param   {string|object}     [swagger]\n * The file path or URL of a Swagger 2.0 API spec, in YAML or JSON format.\n * Or a valid Swagger API object (see https://github.com/swagger-api/swagger-spec/blob/master/versions/2.0.md#swagger-object).\n *\n * @param   {express#Router}    [router]\n * An Express Application or Router that will be used to determine settings (such as case-sensitivity and strict routing)\n * and to register path-parsing middleware.\n *\n * @param   {function}          [callback]\n * It will be called when the API has been parsed, validated, and dereferenced, or when an error occurs.\n *\n * @returns {Middleware}\n * The {@link Middleware} object is returned immediately, but it isn't ready to handle requests until\n * the callback function is called.  The same {@link Middleware} object will be passed to the callback function.\n */\nfunction createMiddleware(swagger, router, callback) {\n  // Shift args if needed\n  if (util.isExpressRouter(swagger)) {\n    router = swagger;\n    swagger = callback = undefined;\n  }\n  else if (!util.isExpressRouter(router)) {\n    callback = router;\n    router = undefined;\n  }\n\n  var middleware = new module.exports.Middleware(router);\n\n  if (swagger) {\n    middleware.init(swagger, callback);\n  }\n\n  return middleware;\n}\n","/home/travis/build/npmtest/node-npmtest-swagger-express-middleware/node_modules/swagger-express-middleware/lib/middleware.js":"'use strict';\n\nmodule.exports = Middleware;\n\nvar _                 = require('lodash'),\n    swaggerParser     = require('swagger-parser'),\n    util              = require('./helpers/util'),\n    MiddlewareContext = require('./context'),\n    DataStore         = require('./data-store'),\n    requestMetadata   = require('./request-metadata'),\n    fileServer        = require('./file-server'),\n    CORS              = require('./cors'),\n    requestParser     = require('./request-parser'),\n    paramParser       = require('./param-parser'),\n    pathParser        = require('./path-parser'),\n    requestValidator  = require('./request-validator'),\n    mock              = require('./mock');\n\n/**\n * Express middleware for the given Swagger API.\n *\n * @param   {express#Router}    [sharedRouter]\n * An Express Application or Router. If provided, this will be used to determine routing settings\n * (case sensitivity, strictness), and to register path-param middleware via {@link Router#param}\n * (see http://expressjs.com/4x/api.html#router.param).\n *\n * @constructor\n */\nfunction Middleware(sharedRouter) {\n  sharedRouter = util.isExpressRouter(sharedRouter) ? sharedRouter : undefined;\n\n  var self = this;\n  var context = new MiddlewareContext(sharedRouter);\n\n  /**\n   * Initializes the middleware with the given Swagger API.\n   * This method can be called again to re-initialize with a new or modified API.\n   *\n   * @param   {string|object}     [swagger]\n   * The file path or URL of a Swagger 2.0 API spec, in YAML or JSON format.\n   * Or a valid Swagger API object (see https://github.com/swagger-api/swagger-spec/blob/master/versions/2.0.md#swagger-object).\n   *\n   * @param   {function}          [callback]\n   * It will be called when the API has been parsed, validated, and dereferenced, or when an error occurs.\n   */\n  this.init = function(swagger, callback) {\n    swaggerParser.parse(swagger, function(err, api, metadata) {\n      if (err) {\n        util.warn(err);\n      }\n\n      context.error = err;\n      context.api = api;\n      context.metadata = metadata;\n      context.emit('change');\n\n      if (_.isFunction(callback)) {\n        callback(err, self, api, metadata);\n      }\n    });\n  };\n\n  /**\n   * Serves the Swagger API file(s) in JSON and YAML formats,\n   * so they can be used with third-party front-end tools like Swagger UI and Swagger Editor.\n   *\n   * @param   {express#Router}    [router]\n   * Express routing options (e.g. `caseSensitive`, `strict`).\n   * If an Express Application or Router is passed, then its routing settings will be used.\n   *\n   * @param   {fileServer.defaultOptions}  [options]\n   * Options for how the files are served (see {@link fileServer.defaultOptions})\n   *\n   * @returns {function[]}\n   */\n  this.files = function(router, options) {\n    if (arguments.length === 1 && !util.isExpressRouter(router) && !util.isExpressRoutingOptions(router)) {\n      // Shift arguments\n      options = router;\n      router = sharedRouter;\n    }\n\n    return fileServer(context, router, options);\n  };\n\n  /**\n   * Annotates the HTTP request (the `req` object) with Swagger metadata.\n   * This middleware populates {@link Request#swagger}.\n   *\n   * @param   {express#Router}    [router]\n   * Express routing options (e.g. `caseSensitive`, `strict`).\n   * If an Express Application or Router is passed, then its routing settings will be used.\n   *\n   * @returns {function[]}\n   */\n  this.metadata = function(router) {\n    return requestMetadata(context, router);\n  };\n\n  /**\n   * Handles CORS preflight requests and sets CORS headers for all requests\n   * according the Swagger API definition.\n   *\n   * @returns {function[]}\n   */\n  this.CORS = function() {\n    return CORS();\n  };\n\n  /**\n   * Parses the HTTP request into typed values.\n   * This middleware populates {@link Request#params}, {@link Request#headers}, {@link Request#cookies},\n   * {@link Request#signedCookies}, {@link Request#query}, {@link Request#body}, and {@link Request#files}.\n   *\n   * @param   {express#Router}    [router]\n   * An Express Application or Router. If provided, this will be used to register path-param middleware\n   * via {@link Router#param} (see http://expressjs.com/4x/api.html#router.param).\n   * If not provided, then path parameters will always be parsed as strings.\n   *\n   * @param   {requestParser.defaultOptions}  [options]\n   * Options for each of the request-parsing middleware (see {@link requestParser.defaultOptions})\n   *\n   * @returns {function[]}\n   */\n  this.parseRequest = function(router, options) {\n    if (arguments.length === 1 && !util.isExpressRouter(router) && !util.isExpressRoutingOptions(router)) {\n      // Shift arguments\n      options = router;\n      router = sharedRouter;\n    }\n\n    return requestParser(options)\n      .concat(paramParser())\n      .concat(pathParser(context, router));\n  };\n\n  /**\n   * Validates the HTTP request against the Swagger API.\n   * An error is sent downstream if the request is invalid for any reason.\n   *\n   * @returns {function[]}\n   */\n  this.validateRequest = function() {\n    return requestValidator(context);\n  };\n\n  /**\n   * Implements mock behavior for HTTP requests, based on the Swagger API.\n   *\n   * @param   {express#Router}    [router]\n   * Express routing options (e.g. `caseSensitive`, `strict`).\n   * If an Express Application or Router is passed, then its routing settings will be used.\n   *\n   * @param   {DataStore}         [dataStore]\n   * The data store that will be used to persist REST resources.\n   * If `router` is an Express Application, then you can set/get the data store\n   * using `router.get(\"mock data store\")`.\n   *\n   * @returns {function[]}\n   */\n  this.mock = function(router, dataStore) {\n    if (arguments.length === 1 &&\n      router instanceof DataStore) {\n      // Shift arguments\n      dataStore = router;\n      router = undefined;\n    }\n\n    return mock(context, router, dataStore);\n  };\n}\n","/home/travis/build/npmtest/node-npmtest-swagger-express-middleware/node_modules/swagger-express-middleware/lib/helpers/util.js":"'use strict';\n\nvar debug       = require('debug'),\n    format      = require('util').format,\n    _           = require('lodash'),\n    swaggerUtil = require('swagger-parser/lib/util');\n\nvar util = module.exports = {\n  /**\n   * Writes messages to stdout.\n   * Log messages are suppressed by default, but can be enabled by setting the DEBUG variable.\n   *\n   * @param   {string}    message     The error message.  May include format strings (%s, %d, %j)\n   * @param   {...*}      [params]    One or more params to be passed to {@link util#format}\n   * @type {function}\n   */\n  debug: debug('swagger:middleware'),\n\n  /**\n   * Writes messages to stderr.\n   * Warning messages are enabled by default, but can be suppressed by setting the WARN variable to \"off\".\n   *\n   * @param   {Error}     [err]       The error, if any\n   * @param   {string}    message     The warning message.  May include format strings (%s, %d, %j)\n   * @param   {...*}      [params]    One or more params to be passed to {@link util#format}\n   */\n  warn: function(err, message, params) {\n    if (process.env.WARN !== 'off') {\n      if (_.isString(err)) {\n        console.warn(format.apply(null, arguments));\n      }\n      else if (arguments.length > 1) {\n        console.warn(format.apply(null, _.drop(arguments, 1)) + ' \\n' + err.stack);\n      }\n      else {\n        console.warn(err.stack);\n      }\n    }\n  },\n\n  /**\n   * Creates an Error object with a formatted message and an HTTP status code.\n   *\n   * @param   {number}    [status]    The HTTP status code (defaults to 500)\n   * @param   {Error}     [err]       The original error, if any\n   * @param   {string}    message     The error message.  May include format strings (%s, %d, %j)\n   * @param   {...*}      [params]    One or more params to be passed to {@link util#format}\n   * @returns {Error}\n   */\n  newError: function(status, err, message, params) {\n    if (_.isString(status)) {\n      message = format.apply(null, arguments);\n      status = 500;\n      err = undefined;\n    }\n    else if (status instanceof Error) {\n      message = format.apply(null, _.drop(arguments, 1));\n      err = status;\n      status = 500;\n    }\n    else if (_.isString(err)) {\n      message = format.apply(null, _.drop(arguments, 1));\n      err = undefined;\n    }\n    else {\n      message = format.apply(null, _.drop(arguments, 2));\n    }\n\n    if (err) {\n      message += ' \\n' + err.message;\n    }\n\n    var newErr = new Error(status + ' Error: ' + message);\n    newErr.status = status;\n\n    if (err) {\n      // Keep the stack trace of the original error\n      newErr.stack = newErr.message + ' \\n' + err.stack;\n    }\n\n    return newErr;\n  },\n\n  /**\n   * Determines whether the given value is an Express Application.\n   * Note: An Express Application is also an Express Router.\n   *\n   * @param   {*} router\n   * @returns {boolean}\n   */\n  isExpressApp: function(router) {\n    return util.isExpressRouter(router) &&\n      _.isFunction(router.get) &&\n      _.isFunction(router.set) &&\n      _.isFunction(router.enabled) &&\n      _.isFunction(router.disabled);\n  },\n\n  /**\n   * Determines whether the given value is an Express Router.\n   * Note: An Express Application is also an Express Router.\n   *\n   * @param   {*} router\n   * @returns {boolean}\n   */\n  isExpressRouter: function(router) {\n    return _.isFunction(router) &&\n      _.isFunction(router.param);\n  },\n\n  /**\n   * Determines whether the given value is an Express routing-options object.\n   *\n   * @param   {*} router\n   * @returns {boolean}\n   */\n  isExpressRoutingOptions: function(router) {\n    return _.isObject(router) &&\n      ('caseSensitive' in router || 'strict' in router || 'mergeParams' in router);\n  },\n\n  /**\n   * Normalizes a path according to the given router's case-sensitivity and strict-routing settings.\n   *\n   * @param   {string}             path\n   * @param   {express#Router}     router\n   * @returns {string}\n   */\n  normalizePath: function(path, router) {\n    var caseSensitive, strict;\n\n    if (!path) {\n      return '';\n    }\n\n    if (util.isExpressApp(router)) {\n      caseSensitive = router.enabled('case sensitive routing');\n      strict = router.enabled('strict routing');\n    }\n    else {\n      // This could be an Express Router, or a POJO\n      caseSensitive = !!router.caseSensitive;\n      strict = !!router.strict;\n    }\n\n    if (!caseSensitive) {\n      path = path.toLowerCase();\n    }\n\n    if (!strict && _.endsWith(path, '/')) {\n      path = path.substr(0, path.length - 1);\n    }\n\n    return path;\n  },\n\n  /**\n   * Formats a date as RFC 1123 (e.g. \"Tue, 05 Nov 1994 02:09:26 GMT\")\n   * @param date\n   * @returns {string}\n   */\n  rfc1123: function(date) {\n    // jscs:disable maximumLineLength\n    var dayName = ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'][date.getUTCDay()];\n    var monthName = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'][date.getUTCMonth()];\n    return [\n      dayName, ', ', _.padLeft(date.getUTCDate(), 2, '0'), ' ', monthName, ' ', date.getUTCFullYear(), ' ',\n      _.padLeft(date.getUTCHours(), 2, '0'), ':', _.padLeft(date.getUTCMinutes(), 2, '0'), ':', _.padLeft(date.getUTCSeconds(), 2, '0'), ' GMT'\n    ].join('');\n    // jscs:enable maximumLineLength\n  },\n\n  /**\n   * Regular Expression that matches Swagger path params.\n   */\n  swaggerParamRegExp: swaggerUtil.swaggerParamRegExp,\n\n  /**\n   * The HTTP methods that Swagger supports\n   * (see https://github.com/swagger-api/swagger-spec/blob/master/versions/2.0.md#pathItemObject)\n   */\n  swaggerMethods: swaggerUtil.swaggerMethods,\n\n  /**\n   * Determines whether the given HTTP request is a valid Swagger request.\n   * That is, its `req.swagger.api`, `req.swagger.path`, and `req.swagger.operation` properties are set.\n   * @param   {Request}   req\n   * @returns {boolean}\n   */\n  isSwaggerRequest: function(req) {\n    // If req.swagger.operation is set, then so are req.swagger.api and req.swagger.path\n    return req.swagger && req.swagger.operation;\n  },\n\n  /**\n   * Returns a comma-delimited list of allowed HTTP methods for the given Swagger path.\n   * This is useful for setting HTTP headers such as Allow and Access-Control-Allow-Methods.\n   *\n   * @param   {object}    path    A Path object, from the Swagger API.\n   * @returns {string}\n   */\n  getAllowedMethods: function(path) {\n    return util.swaggerMethods\n      .filter(function(method) { return !!path[method]; })\n      .join(', ')\n      .toUpperCase();\n  },\n\n  /**\n   * Returns the given operation's Response objects that have HTTP response codes between\n   * the given min and max (inclusive).\n   *\n   * @param   {object}    operation   An Operation object, from the Swagger API.\n   * @param   {integer}   min         The minimum HTTP response code to include\n   * @param   {integer}   max         The maximum HTTP response code to include\n   *\n   * @returns {{code: integer, api: object}[]}\n   * An array of HTTP response codes and their corresponding Response objects,\n   * sorted by response code (\"default\" comes last).\n   */\n  getResponsesBetween: function(operation, min, max) {\n    return _.map(operation.responses,\n      function(response, responseCode) {\n        return {\n          code: parseInt(responseCode) || responseCode,\n          api: response\n        };\n      })\n      .sort(function(a, b) {\n        // Sort by response code.  \"default\" comes last.\n        a = _.isNumber(a.code) ? a.code : 999;\n        b = _.isNumber(b.code) ? b.code : 999;\n        return a - b;\n      })\n      .filter(function(response) {\n        return (response.code >= min && response.code <= max) || _.isString(response.code);\n      });\n  },\n\n  /**\n   * Returns the combined parameters for the given path and operation.\n   *\n   * @param   {object}    path        A Path object, from the Swagger API\n   * @param   {object}    operation   An Operation object, from the Swagger API\n   * @returns {object[]}              An array of Parameter objects\n   */\n  getParameters: function(path, operation) {\n    var pathParams = [], operationParams = [];\n\n    // Get the path and operation parameters\n    if (path && path.parameters) {\n      pathParams = path.parameters;\n    }\n    if (operation && operation.parameters) {\n      operationParams = operation.parameters;\n    }\n\n    // Combine the path and operation parameters,\n    // with the operation params taking precedence over the path params\n    return _.unique(operationParams.concat(pathParams), function(param) {\n      return param.name + param.in;\n    });\n  },\n\n  /**\n   * Gets the JSON schema for the given operation, based on its \"body\" or \"formData\" parameters.\n   *\n   * @param   {object}    path        A Path object, from the Swagger API\n   * @param   {object}    operation   An Operation object, from the Swagger API\n   * @returns {object}                A JSON schema object\n   */\n  getRequestSchema: function(path, operation) {\n    var params = util.getParameters(path, operation);\n\n    // If there's a \"body\" parameter, then use its schema\n    var bodyParam = _.find(params, {in: 'body'});\n    if (bodyParam) {\n      if (bodyParam.schema.type === 'array') {\n        return bodyParam.schema.items;\n      }\n      else {\n        return bodyParam.schema;\n      }\n    }\n    else {\n      var schema = {type: 'object', required: [], properties: {}};\n\n      // If there are \"formData\" parameters, then concatenate them into a single JSON schema\n      _.where(params, {in: 'formData'}).forEach(function(param) {\n        schema.properties[param.name] = param;\n        if (param.required) {\n          schema.required.push(param.name);\n        }\n      });\n\n      return schema;\n    }\n  }\n};\n","/home/travis/build/npmtest/node-npmtest-swagger-express-middleware/node_modules/swagger-express-middleware/lib/context.js":"'use strict';\n\nmodule.exports = MiddlewareContext;\n\nvar _      = require('lodash'),\n    events = require('events');\n\n// Inheritance\n_.extend(MiddlewareContext.prototype, events.EventEmitter.prototype);\n\n/**\n * A context object that is shared by all middleware functions of a {@link Middleware} instance.\n *\n * @extends EventEmitter\n * @constructor\n */\nfunction MiddlewareContext(router) {\n  events.EventEmitter.call(this);\n\n  /**\n   * Express routing options (e.g. `caseSensitive`, `strict`).\n   * If set to an Express Application or Router, then its routing settings will be used.\n   * @type {express#Router}\n   */\n  this.router = router || {};\n\n  /**\n   * The parsed Swagger API\n   * @type {SwaggerObject}\n   */\n  this.api = null;\n\n  /**\n   * If the Swagger API contains errors, this will be set\n   * @type {Error}\n   */\n  this.error = null;\n}\n\n","/home/travis/build/npmtest/node-npmtest-swagger-express-middleware/node_modules/swagger-express-middleware/lib/data-store/index.js":"'use strict';\n\nmodule.exports = DataStore;\n\nvar _        = require('lodash'),\n    util     = require('../helpers/util'),\n    Resource = require('./resource');\nrequire('./buffer-polyfill');\n\n/**\n * An abstract base class for data-storage of REST resources.\n * @constructor\n */\nfunction DataStore() {\n  /**\n   * The Express Application or Router that's used to determine case-sensitivity and/or strict matching\n   * of collection paths and resource names.\n   *\n   * @type {express#Router}\n   * @protected\n   */\n  this.__router = {};\n}\n\n/**\n * Returns the given resource.\n *\n * @param   {Resource|string}  resource    The resource (path) or Resource object to be retrieved\n *\n * @param   {function}  callback\n * An error-first callback.  The second parameter is the {@link Resource} object,\n * or undefined if no match was found.\n */\nDataStore.prototype.get = function(resource, callback) {\n  var self = this;\n\n  if (_.isString(resource)) {\n    resource = new Resource(resource);\n  }\n\n  openCollection(self, resource, function(err, collection, resources) {\n    if (err) {\n      doCallback(callback, err);\n    }\n    else {\n      // Find the resource\n      resource = _.find(resources, resource.filter(self.__router));\n      doCallback(callback, null, resource);\n    }\n  });\n};\n\n//noinspection JSClosureCompilerSyntax\n/**\n * Saves the given resource(s) to the data store.\n * If any of the resources already exist, the new data is merged with the existing data.\n *\n * @param   {...Resource|Resource[]}    resources\n * The resource(s) or array of resources to be saved\n *\n * @param   {function}  [callback]\n * An error-first callback.  The second parameter is the {@link Resource} object\n * or array of {@link Resource} objects that were saved.\n */\nDataStore.prototype.save = function(resources, callback) {\n  call(this, save, arguments);\n};\n\n/**\n * Removes the given resource from the data store.\n *\n * @param   {...Resource|Resource[]}    resources\n * The resource(s) or array of resources to be removed\n *\n * @param   {function}  [callback]\n * An error-first callback.  The second parameter is the {@link Resource} object\n * or array of {@link Resource} objects that were removed.\n */\nDataStore.prototype.delete = DataStore.prototype.remove = function(resources, callback) {\n  call(this, remove, arguments);\n};\n\n/**\n * Returns all resources in the given collection.\n *\n * @param   {string}    collection\n * The collection path (e.g. \"/\", \"/users\", \"/users/jdoe/orders/\")\n *\n * @param   {function}  callback\n * An error-first callback.  The second parameter is the array of {@link Resource} objects in the collection.\n * If there are no resources for the given collection, then the array is empty.\n */\nDataStore.prototype.getCollection = function(collection, callback) {\n  var self = this;\n\n  openCollection(self, collection, function(err, collection, resources) {\n    if (err) {\n      doCallback(callback, err);\n    }\n    else {\n      // Return the resources in the collection\n      resources = _.filter(resources, collection.filter(self.__router, true));\n      doCallback(callback, null, resources);\n    }\n  });\n};\n\n/**\n * Removes all resources in the given collection.\n *\n * @param   {string}        collection\n * The collection path (e.g. \"/\", \"/users\", \"/users/jdoe/orders/\")\n *\n * @param   {function}      callback\n * An error-first callback.  The second parameter is the array of {@link Resource} objects that were deleted.\n * If nothing was deleted, then the array is empty.\n */\nDataStore.prototype.deleteCollection = DataStore.prototype.removeCollection = function(collection, callback) {\n  var self = this;\n\n  openCollection(self, collection, function(err, collection, resources) {\n    if (err) {\n      doCallback(callback, err);\n    }\n    else {\n      // Remove all resources in the collection\n      var removed = _.remove(resources, collection.filter(self.__router, true));\n\n      if (removed.length > 0) {\n        // Normalize the collection name\n        var collectionName = collection.valueOf(self.__router, true);\n\n        // Save the changes\n        self.__saveDataStore(collectionName, resources, function(err) {\n          if (err) {\n            doCallback(callback, err);\n          }\n          else {\n            doCallback(callback, null, removed);\n          }\n        });\n      }\n      else {\n        doCallback(callback, null, []);\n      }\n    }\n  });\n};\n\n/* istanbul ignore next: abstract method */\n/**\n * Opens the underlying data-store and returns its data.\n * Depending on the implementation, this may be the contents of a flat file, a database query, etc. instead.\n *\n * @param   {string}    collection\n * The Resource collection that is being operated upon.\n * Some DataStore implementations may use this to determine which data to return.\n *\n * @param   {function}  callback\n * An error-first callback.  The second parameter is an array of {@link Resource} objects\n * that correspond to the given `collection` and `name`.\n *\n * @protected\n */\nDataStore.prototype.__openDataStore = function(collection, callback) {};\n\n/* istanbul ignore next: abstract method */\n/**\n * Persists changes to the underlying data-store.\n * Depending on the implementation, this may write to a flat file, a database, etc. instead.\n *\n * @param   {string}        collection\n * The Resource collection that is being operated upon.\n * Some DataStore implementations may use this to determine which data to persist/overwrite.\n *\n * @param   {Resource[]}    resources\n * An array of {@link Resource} objects that should be persisted to the underlying data-store.\n *\n * @param   {function}      callback\n * An error-first callback.  Called when the data has been persisted, or an error occurs.\n *\n * @protected\n */\nDataStore.prototype.__saveDataStore = function(collection, resources, callback) {};\n\n/**\n * Saves the given resources to the data store.\n * If any of the resources already exist, the new data is merged with the existing data.\n *\n * @param   {DataStore}     dataStore           The DataStore to operate on\n * @param   {string}        collectionName      The collection that all the resources belong to\n * @param   {Resource[]}    resources           The Resources to be saved\n * @param   {function}      callback            Callback function\n */\nfunction save(dataStore, collectionName, resources, callback) {\n  // Open the data store\n  dataStore.__openDataStore(collectionName, function(err, existingResources) {\n    if (err) {\n      return callback(err);\n    }\n\n    resources.forEach(function(resource) {\n      // Set the timestamp properties\n      var now = Date.now();\n      resource.createdOn = new Date(now);\n      resource.modifiedOn = new Date(now);\n\n      // Does the resource already exist?\n      var existing = _.find(existingResources, resource.filter(dataStore.__router));\n      if (existing) {\n        // Merge the new data into the existing resource\n        util.debug('%s already exists. Merging new data with existing data.', resource.toString());\n        existing.merge(resource);\n\n        // Update the calling code's reference to the resource\n        _.extend(resource, existing);\n      }\n      else {\n        existingResources.push(resource);\n      }\n    });\n\n    // Save the changes\n    dataStore.__saveDataStore(collectionName, existingResources, function(err) {\n      callback(err, resources);\n    });\n  });\n}\n\n/**\n * Removes the given resource from the data store.\n *\n * @param   {DataStore}     dataStore           The DataStore to operate on\n * @param   {string}        collectionName      The collection that all the resources belong to\n * @param   {Resource[]}    resources           The Resources to be removed\n * @param   {function}      callback            Callback function\n */\nfunction remove(dataStore, collectionName, resources, callback) {\n  // Open the data store\n  dataStore.__openDataStore(collectionName, function(err, existingResources) {\n    if (err) {\n      return callback(err);\n    }\n\n    // Remove the resources from the existing resources\n    var removedResources = [];\n    resources.forEach(function(resource) {\n      var removed = _.remove(existingResources, resource.filter(dataStore.__router));\n      removedResources = removedResources.concat(removed);\n    });\n\n    if (removedResources.length > 0) {\n      // Save the changes\n      dataStore.__saveDataStore(collectionName, existingResources, function(err) {\n        if (err) {\n          callback(err);\n        }\n        else {\n          callback(null, removedResources);\n        }\n      });\n    }\n    else {\n      callback(null, []);\n    }\n  });\n}\n\n/**\n * Opens the given collection.\n *\n * @param   {DataStore}         dataStore       The DataStore to operate on\n * @param   {string|Resource}   collection      The collection path or a Resource object\n * @param   {function}          callback        Called with Error, collection Resource, and Resource array\n */\nfunction openCollection(dataStore, collection, callback) {\n  if (_.isString(collection)) {\n    collection = new Resource(collection, '', '');\n  }\n  else if (!(collection instanceof Resource)) {\n    throw util.newError('Expected a string or Resource object. Got a %s instead.', typeof(collection));\n  }\n\n  // Normalize the collection name\n  var collectionName = collection.valueOf(dataStore.__router, true);\n\n  // Open the data store\n  dataStore.__openDataStore(collectionName, function(err, resources) {\n    callback(err, collection, resources);\n  });\n}\n\n/**\n * Calls the given callback with the given arguments, if the callback is defined.\n *\n * @param   {function|*}    callback\n * @param   {Error|null}    err\n * @param   {*}             arg\n */\nfunction doCallback(callback, err, arg) {\n  if (_.isFunction(callback)) {\n    callback(err, arg);\n  }\n}\n\n/**\n * Calls the given function with normalized parameters:\n * the DataStore, collection name, an array of {@link Resource} objects, and a callback function.\n *\n * The given function might be called multiple times.  Each time it is called, the array of resources\n * will all belong to the same collection.\n *\n * @param   {DataStore} dataStore   The DataStore to operate on\n * @param   {function}  fn          The function to be called\n * @param   {arguments} args        The non-normalized arguments (one resource, multiple resources, a resource array, a callback)\n */\nfunction call(dataStore, fn, args) {\n  var resources, callback;\n\n  // If only a single resource was passed-in, then only a single resource will be passed-back\n  var singleResource = _.first(args) instanceof Resource && (args.length === 0 || _.isFunction(args[1]));\n\n  // Normalize the arguments\n  if (_.isFunction(_.last(args))) {\n    resources = _.flatten(_.initial(args), true);\n    callback = _.last(args);\n  }\n  else {\n    resources = _.flatten(args, true);\n    callback = _.noop;\n  }\n\n  // Group the resources into collections\n  var collections = {};\n  for (var i = 0; i < resources.length; i++) {\n    var resource = resources[i];\n    if (!(resource instanceof Resource)) {\n      throw util.newError('Expected a Resource object, but parameter %d is a %s.', i + 1, typeof(resource));\n    }\n\n    var collectionName = resource.valueOf(dataStore.__router, true);\n    var collection = collections[collectionName] || (collections[collectionName] = []);\n    collection.push(resource);\n  }\n\n  // Call the function for each collection of resources\n  var collectionNames = Object.keys(collections);\n  var collectionIndex = 0, processedResources = [];\n  processNextCollection();\n\n  function processNextCollection(err, resources) {\n    if (err) {\n      // An error occurred, so abort.\n      finished(err);\n      return;\n    }\n\n    if (resources) {\n      // Add the resources to the list of processed resources\n      processedResources = processedResources.concat(resources);\n    }\n\n    if (collectionIndex >= collectionNames.length) {\n      // We're done processing all collections, so return the results\n      finished(null, processedResources);\n    }\n    else {\n      // Process the next collection\n      var collectionName = collectionNames[collectionIndex++];\n      fn(dataStore, collectionName, collections[collectionName], processNextCollection);\n    }\n  }\n\n  function finished(err, resources) {\n    if (err) {\n      callback(err);\n    }\n    else {\n      // Call the callback with a single resource or an array of resources\n      callback(null, singleResource ? resources[0] : resources);\n    }\n  }\n}\n","/home/travis/build/npmtest/node-npmtest-swagger-express-middleware/node_modules/swagger-express-middleware/lib/data-store/resource.js":"'use strict';\n\nmodule.exports = Resource;\n\nvar util = require('../helpers/util'),\n    _    = require('lodash');\n\n/**\n * Represents a single REST resource, such as a web page, a file, a piece of JSON data, etc.\n * Each Resource is uniquely identifiable by its collection and its name.\n *\n * Examples:\n *  /static/pages/index.html\n *      - Collection: /static/pages\n *      - Name: /index.html\n *\n *  /restaurants/washington/seattle/\n *      - Collection: /restaurants/washington\n *      - Name: /seattle/\n *\n *  /restaurants/washington/seattle/joes-diner\n *      - Collection: /restaurants/washington/seattle\n *      - Name: /joes-diner\n *  /\n *      - Collection: (empty string)\n *      - Name: /\n *\n *\n * @param   {string}    [path]      The full resource path (collection and name), or just the collection path\n * @param   {string}    [name]      The resource name (if `path` is just the collection path)\n * @param   {*}         [data]      The resource's data\n * @constructor\n */\nfunction Resource(path, name, data) {\n  switch (arguments.length) {\n    case 0:\n      this.collection = '';\n      this.name = '/';\n      this.data = undefined;\n      break;\n    case 1:\n      this.collection = getCollectionFromPath(path);\n      this.name = getNameFromPath(path);\n      this.data = undefined;\n      break;\n    case 2:\n      this.merge(name);\n      this.collection = getCollectionFromPath(path);\n      this.name = getNameFromPath(path);\n      break;\n    default:\n      this.collection = normalizeCollection(path);\n      this.name = normalizeName(name);\n      this.merge(data);\n  }\n\n  this.createdOn = null;\n  this.modifiedOn = null;\n}\n\n/**\n * Overrides {@link Object#toString}.\n */\nResource.prototype.toString = function() {\n  return this.collection + this.name;\n};\n\n/**\n * Merges data into this resource's existing data.\n *\n * @param   {Resource|*}    other\n * The data to merge.  If `other` is a {@link Resource}, then it's {@link Resource#data} will be used.\n */\nResource.prototype.merge = function(other) {\n  this.modifiedOn = new Date();\n\n  var otherData = other ? other instanceof Resource ? other.data : other : other;\n\n  // Merge with the other resource's data, if possible; otherwise, overwrite.\n  if ((_.isArray(this.data) && _.isArray(otherData)) ||\n    (_.isPlainObject(this.data) && _.isPlainObject(otherData))) {\n    _.merge(this.data, otherData);\n  }\n  else {\n    this.data = otherData;\n  }\n};\n\n/**\n * Overrides {@link Object#valueOf} to support extra options\n * for comparison against other {@link Resource} objects.\n *\n * @param   {express#Router}    [router]\n * An Express Application or Router that will be used to determine case-sensitivity and strictness.\n *\n * @param   {boolean}           [collectionOnly]\n * If true, then only the {@link Resource#collection} property will be returned.\n */\nResource.prototype.valueOf = function(router, collectionOnly) {\n  if (router) {\n    var myValue = collectionOnly ? this.collection : this.toString();\n    return util.normalizePath(myValue, router);\n  }\n  else {\n    return this.toString();\n  }\n};\n\n/**\n * Creates a predicate function that compares this {@link Resource} object\n * to other {@link Resource} objects.\n *\n * @param   {express#Router}    [router]\n * An Express Application or Router that will be used to determine case-sensitivity and strictness.\n *\n * @param   {boolean}           [collectionOnly]\n * If true, then only the {@link Resource#collection} property will be returned.\n *\n * @returns {function}\n * A comparison function that can be passed to filtering methods such as\n * {@link Array#filter}, {@link Array#find}, and {@link Array#some}.\n */\nResource.prototype.filter = function(router, collectionOnly) {\n  var myValue = this.valueOf(router, collectionOnly);\n\n  return function(resource) {\n    return myValue === resource.valueOf(router, collectionOnly);\n  };\n};\n\n/**\n * Deserializes JSON or POJO data into {@link Resource} objects.\n *\n * @param   {string|object|object[]}    json\n * A JSON string or POJO object/array containing the data for one or more Resource objects.\n *\n * @returns {Resource|Resource[]}\n * If `data` is an array, or a JSON string containing an array,\n * then an array of {@link Resource} objects is returned.\n * Otherwise, a single {@link Resource} object is returned.\n */\nResource.parse = function(json) {\n  if (!_.isString(json)) {\n    // Convert the data to JSON, to match real-world serialization\n    json = JSON.stringify(json);\n  }\n\n  json = JSON.parse(json);\n\n  var isArray = _.isArray(json);\n  if (!isArray) {\n    json = [json];\n  }\n\n  var resources = [];\n  json.forEach(function(pojo) {\n    var resource = new Resource(pojo.collection, pojo.name, pojo.data);\n    resource.createdOn = new Date(pojo.createdOn);\n    resource.modifiedOn = new Date(pojo.modifiedOn);\n    resources.push(resource);\n  });\n\n  return isArray ? resources : resources[0];\n};\n\n/**\n * Returns the normalized collection path from the given full resource path.\n *\n * @param   {string}    path    The full resource path (e.g. \"/restaurants/washington/seattle/joes-diner\")\n * @returns {string}            The normalized collection path (e.g. \"/restaurants/washington/seattle\")\n */\nfunction getCollectionFromPath(path) {\n  path = _(path).toString();\n  var lastSlash = path.substring(0, path.length - 1).lastIndexOf('/');\n  if (lastSlash === -1) {\n    return '';\n  }\n  else {\n    return normalizeCollection(path.substring(0, lastSlash));\n  }\n}\n\n/**\n * Returns the normalized resource name from the given full resource path.\n *\n * @param   {string}    path    The full resource path (e.g. \"/restaurants/washington/seattle/joes-diner\")\n * @returns {string}            The normalized resource name (e.g. \"/joes-diner\")\n */\nfunction getNameFromPath(path) {\n  path = _(path).toString();\n  var lastSlash = path.substring(0, path.length - 1).lastIndexOf('/');\n  if (lastSlash === -1) {\n    return normalizeName(path);\n  }\n  else {\n    return normalizeName(path.substring(lastSlash));\n  }\n}\n\n/**\n * Normalizes collection paths.\n *\n * Examples:\n *  /               => (empty string)\n *  /users          => /users\n *  /users/jdoe/    => /users/jdoe\n *\n * @param   {string}    collection\n * @returns {string}\n */\nfunction normalizeCollection(collection) {\n  // Normalize the root path as an empty string\n  collection = _(collection).toString();\n  if (_.isEmpty(collection) || collection === '/' || collection === '//') {\n    return '';\n  }\n\n  // Add a leading slash\n  if (!_.startsWith(collection, '/')) {\n    collection = '/' + collection;\n  }\n\n  // Remove a trailing slash\n  if (_.endsWith(collection, '/')) {\n    collection = collection.substring(0, collection.length - 1);\n  }\n\n  return collection;\n}\n\n/**\n * Normalizes resource names.\n *\n * Examples:\n *  /               => /\n *  /users          => /users\n *  users/          => /users/\n *  /users/jdoe     => ERROR! Slashes aren't allowed in the middle\n *\n * @param   {string}    name\n * @returns {string}\n */\nfunction normalizeName(name) {\n  // Normalize directories as a single slash\n  name = _(name).toString();\n  if (_.isEmpty(name) || name === '/' || name === '//') {\n    return '/';\n  }\n\n  // Add a leading slash\n  if (!_.startsWith(name, '/')) {\n    name = '/' + name;\n  }\n\n  // Don't allow slashes in the middle\n  if (_.contains(name.substring(1, name.length - 1), '/')) {\n    throw util.newError('Resource names cannot contain slashes');\n  }\n\n  return name;\n}\n","/home/travis/build/npmtest/node-npmtest-swagger-express-middleware/node_modules/swagger-express-middleware/lib/data-store/buffer-polyfill.js":"'use strict';\n\n// 0.10.x versions of Node serialize Buffers as arrays instead of objects\nif (process.version.substring(0, 6) === 'v0.10.') {\n  Buffer.prototype.toJSON = function() {\n    return {\n      type: 'Buffer',\n      data: Array.prototype.slice.call(this, 0)\n    };\n  };\n}\n","/home/travis/build/npmtest/node-npmtest-swagger-express-middleware/node_modules/swagger-express-middleware/lib/request-metadata.js":"'use strict';\n\nmodule.exports = requestMetadata;\n\nvar util = require('./helpers/util'),\n    _    = require('lodash');\n\n/**\n * Adds a {@link Request#swagger} property with Swagger metadata for each HTTP request.\n *\n * @param   {MiddlewareContext} context\n * @param   {express#Router}    router\n * @returns {function[]}\n */\nfunction requestMetadata(context, router) {\n  router = router || context.router;\n\n  return [\n    swaggerMetadata,\n    swaggerApiMetadata,\n    swaggerPathMetadata,\n    swaggerOperationMetadata,\n    swaggerParamsMetadata,\n    swaggerSecurityMetadata\n  ];\n\n  /**\n   * Sets `req.swagger.api`\n   */\n  function swaggerApiMetadata(req, res, next) {\n    // Only set req.swagger.api if the request is under the API's basePath\n    if (context.api) {\n      var basePath = util.normalizePath(context.api.basePath, router);\n      var reqPath = util.normalizePath(req.path, router);\n      if (_.startsWith(reqPath, basePath)) {\n        req.swagger.api = context.api;\n      }\n    }\n\n    next();\n  }\n\n  /**\n   * Sets `req.swagger.path`\n   */\n  function swaggerPathMetadata(req, res, next) {\n    if (req.swagger.api) {\n      var relPath = getRelativePath(req);\n      var relPathNormalized = util.normalizePath(relPath, router);\n\n      // Search for a matching path\n      Object.keys(req.swagger.api.paths).some(function(swaggerPath) {\n        var swaggerPathNormalized = util.normalizePath(swaggerPath, router);\n\n        if (swaggerPathNormalized === relPathNormalized) {\n          // We found an exact match (i.e. a path with no parameters)\n          req.swagger.path = req.swagger.api.paths[swaggerPath];\n          req.swagger.pathName = swaggerPath;\n          return true;\n        }\n        else if (req.swagger.path === null && pathMatches(relPathNormalized, swaggerPathNormalized)) {\n          // We found a possible match, but keep searching in case we find an exact match\n          req.swagger.path = req.swagger.api.paths[swaggerPath];\n          req.swagger.pathName = swaggerPath;\n        }\n      });\n\n      if (req.swagger.path) {\n        util.debug('%s %s matches Swagger path %s', req.method, req.path, req.swagger.pathName);\n      } else {\n        util.warn('WARNING! Unable to find a Swagger path that matches \"%s\"', req.path);\n      }\n    }\n\n    next();\n  }\n}\n\n/**\n * Creates the `req.swagger` object.\n */\nfunction swaggerMetadata(req, res, next) {\n  /**\n   * The Swagger Metadata that is added to each HTTP request.\n   * This object is exposed as `req.swagger`.\n   *\n   * @name Request#swagger\n   */\n  req.swagger = {\n    /**\n     * The complete Swagger API object.\n     * (see https://github.com/swagger-api/swagger-spec/blob/master/versions/2.0.md#swagger-object)\n     * @type {SwaggerObject|null}\n     */\n    api: null,\n\n    /**\n     * The Swagger path name, as it appears in the Swagger API.\n     * (e.g. \"/users/{username}/orders/{orderId}\")\n     * @type {string}\n     */\n    pathName: '',\n\n    /**\n     * The Path object from the Swagger API.\n     * (see https://github.com/swagger-api/swagger-spec/blob/master/versions/2.0.md#pathItemObject)\n     * @type {object|null}\n     */\n    path: null,\n\n    /**\n     * The Operation object from the Swagger API.\n     * (see https://github.com/swagger-api/swagger-spec/blob/master/versions/2.0.md#operationObject)\n     * @type {object|null}\n     */\n    operation: null,\n\n    /**\n     * The Parameter objects that apply to this request.\n     * (see https://github.com/swagger-api/swagger-spec/blob/master/versions/2.0.md#parameter-object-)\n     * @type {object[]}\n     */\n    params: [],\n\n    /**\n     * The Security Requirement objects that apply to this request.\n     * (see https://github.com/swagger-api/swagger-spec/blob/master/versions/2.0.md#securityRequirementObject)\n     * @type {object[]}\n     */\n    security: []\n  };\n\n  next();\n}\n\n/**\n * Sets `req.swagger.operation`\n */\nfunction swaggerOperationMetadata(req, res, next) {\n  if (req.swagger.path) {\n    var method = req.method.toLowerCase();\n\n    if (method in req.swagger.path) {\n      req.swagger.operation = req.swagger.path[method];\n    }\n    else {\n      util.warn('WARNING! Unable to find a Swagger operation that matches %s %s', req.method.toUpperCase(), req.path);\n    }\n  }\n\n  next();\n}\n\n/**\n * Sets `req.swagger.params`\n */\nfunction swaggerParamsMetadata(req, res, next) {\n  req.swagger.params = util.getParameters(req.swagger.path, req.swagger.operation);\n  next();\n}\n\n/**\n * Sets `req.swagger.security`\n */\nfunction swaggerSecurityMetadata(req, res, next) {\n  if (req.swagger.operation) {\n    // Get the security requirements for this operation (or the global API security)\n    req.swagger.security = req.swagger.operation.security || req.swagger.api.security || [];\n  }\n  else if (req.swagger.api) {\n    // Get the global security requirements for the API\n    req.swagger.security = req.swagger.api.security || [];\n  }\n\n  next();\n}\n\n/**\n * Returns the HTTP request path, relative to the Swagger API's basePath.\n *\n * @param   {Request}   req\n * @returns {string}\n */\nfunction getRelativePath(req) {\n  if (!req.swagger.api.basePath) {\n    return req.path;\n  }\n  else {\n    return req.path.substr(req.swagger.api.basePath.length);\n  }\n}\n\n/**\n * Determines whether the given HTTP request path matches the given Swagger path.\n *\n * @param   {string}    path            The request path (e.g. \"/users/jdoe/orders/1234\")\n * @param   {string}    swaggerPath     The Swagger path (e.g. \"/users/{username}/orders/{orderId}\")\n * @returns {boolean}\n */\nfunction pathMatches(path, swaggerPath) {\n  // Convert the Swagger path to a RegExp\n  var pathPattern = swaggerPath.replace(util.swaggerParamRegExp, function(match, paramName) {\n    return '([^/]+)';\n  });\n\n  // NOTE: This checks for an EXACT, case-sensitive match\n  var pathRegExp = new RegExp('^' + pathPattern + '$');\n\n  return pathRegExp.test(path);\n}\n","/home/travis/build/npmtest/node-npmtest-swagger-express-middleware/node_modules/swagger-express-middleware/lib/file-server.js":"'use strict';\n\nmodule.exports = fileServer;\n\nvar _    = require('lodash'),\n    path = require('path'),\n    util = require('./helpers/util');\n\n/**\n * Serves the Swagger API file(s) in JSON and YAML formats,\n * so they can be used with third-party front-end tools like Swagger UI and Swagger Editor.\n *\n * @param   {MiddlewareContext}             context\n * @param   {express#Router}                [router]\n * @param   {fileServer.defaultOptions}     [options]\n * @returns {function[]}\n */\nfunction fileServer(context, router, options) {\n  router = router || context.router;\n\n  // Override default options\n  options = _.merge({}, fileServer.defaultOptions, options);\n\n  // Alias the `apiPath` property as dereferencedJsonPath\n  options.dereferencedJsonPath = options.dereferencedJsonPath || options.apiPath;\n\n  // Only return the middleware that's allowed\n  var middleware = [];\n  options.dereferencedJsonPath && middleware.push(serveDereferencedSwaggerFile);\n  options.rawFilesPath && middleware.push(serveRawSwaggerFiles);\n  return middleware;\n\n  /**\n   * Serves the fully-dereferenced Swagger API in JSON format.\n   */\n  function serveDereferencedSwaggerFile(req, res, next) {\n    if (req.method === 'GET' || req.method === 'HEAD') {\n      var configPath = getConfiguredPath(options.dereferencedJsonPath);\n      configPath = util.normalizePath(configPath, router);\n      var reqPath = util.normalizePath(req.path, router);\n\n      if (reqPath === configPath) {\n        if (context.api) {\n          util.debug('%s %s => Sending the Swagger API as JSON', req.method, req.path);\n          res.json(context.api);\n        }\n        else {\n          util.warn('WARNING! The Swagger API is empty. Sending an HTTP 500 response to %s %s', req.method, req.path);\n          res.status(500).json({});\n        }\n        return;\n      }\n    }\n\n    next();\n  }\n\n  /**\n   * Serves the raw Swagger file(s).\n   */\n  function serveRawSwaggerFiles(req, res, next) {\n    if (req.method === 'GET' || req.method === 'HEAD') {\n      var configPath = getConfiguredPath(options.rawFilesPath);\n      configPath = util.normalizePath(configPath, router);\n      var reqPath = util.normalizePath(req.path, router);\n\n      if (_.startsWith(reqPath, configPath) && context.metadata) {\n        // Get the normalized, relative path of the requested file\n        var relativePath = req.path.substring(configPath.length);\n        if (_.startsWith(relativePath, '/')) {\n          relativePath = relativePath.substring(1);\n        }\n        relativePath = path.normalize(util.normalizePath(relativePath, router));\n\n        // See if any of the Swagger files match this path\n        var filePath = _.find(context.metadata.files, function(file) {\n          var relativeFile = path.relative(context.metadata.baseDir, file);\n          relativeFile = util.normalizePath(relativeFile, router);\n          return relativeFile === relativePath;\n        });\n\n        if (filePath) {\n          // Normalize the file path (required for Windows)\n          filePath = path.normalize(filePath);\n\n          util.debug('%s %s => Sending file %s', req.method, req.path, filePath);\n          res.sendFile(filePath);\n          return;\n        }\n        else {\n          util.debug('%s %s does not match any files in the Swagger API', req.method, req.path);\n        }\n      }\n    }\n\n    next();\n  }\n\n  /**\n   * Prefixes the given path with the API's basePath, if that option is enabled and the API has a basePath.\n   * @param   {string}    path\n   * @returns {string}\n   */\n  function getConfiguredPath(path) {\n    if (options.useBasePath && context.api && context.api.basePath) {\n      return context.api.basePath + path;\n    }\n    else {\n      return path;\n    }\n  }\n}\n\nfileServer.defaultOptions = {\n  /**\n   * Determines whether the file paths are prefixed with the Swagger API's `basePath` value.\n   * For example, if the `basePath` in the Swagger API is \"/api/v1\", then the Swagger JSON file\n   * would be served at \"/api/v1/api-docs/\" instead of \"/api-docs/\".\n   *\n   * @type {boolean}\n   */\n  useBasePath: false,\n\n  /**\n   * The path that will serve the fully dereferenced Swagger API in JSON format.\n   * This file should work with any third-party tools, even if they don't support YAML,\n   * `$ref` pointers, or mutli-file Swagger APIs.\n   *\n   * To disable serving this file, set the path to a falsy value (such as an empty string).\n   *\n   * @type {string}\n   * @alias dereferencedJsonPath\n   */\n  apiPath: '/api-docs/',\n\n  /**\n   * The path that will serve the raw Swagger API file(s).\n   * For example, assume that your API consists of the following files:\n   *\n   *  - Main.yaml\n   *  - Users.json\n   *  - Products/Get-Products.yml\n   *  - Products/Post-Products.yaml\n   *\n   * By default, each of these files would be served at:\n   *\n   *  - /api-docs/Main.yaml\n   *  - /api-docs/Users.json\n   *  - /api-docs/Products/Get-Products.yml\n   *  - /api-docs/Products/Post-Products.yaml\n   *\n   * To disable serving raw Swagger files, set the path to a falsy value (such as an empty string).\n   *\n   * @type {string}\n   */\n  rawFilesPath: '/api-docs/'\n};\n","/home/travis/build/npmtest/node-npmtest-swagger-express-middleware/node_modules/swagger-express-middleware/lib/cors.js":"'use strict';\n\nmodule.exports = CORS;\n\nvar util = require('./helpers/util'),\n    _    = require('lodash');\n\n// The CORS headers\nvar accessControl = {\n  allowOrigin: 'access-control-allow-origin',\n  allowMethods: 'access-control-allow-methods',\n  allowHeaders: 'access-control-allow-headers',\n  allowCredentials: 'access-control-allow-credentials',\n  maxAge: 'access-control-max-age'\n};\n\n/**\n * Handles CORS preflight requests and sets CORS headers for all requests according the Swagger API definition.\n *\n * @returns {function[]}\n */\nfunction CORS() {\n  return [corsHeaders, corsPreflight];\n}\n\n/**\n * Sets the CORS headers.  If default values are specified in the Swagger API, then those values are used.\n * Otherwise, sensible defaults are used.\n */\nfunction corsHeaders(req, res, next) {\n  // Get the default CORS response headers as specified in the Swagger API\n  var responseHeaders = getResponseHeaders(req);\n\n  // Set each CORS header\n  _.each(accessControl, function(header) {\n    if (responseHeaders[header] !== undefined) {\n      // Set the header to the default value from the Swagger API\n      res.set(header, responseHeaders[header]);\n    }\n    else {\n      // Set the header to a sensible default\n      switch (header) {\n        case accessControl.allowOrigin:\n          // By default, allow the origin host. Fallback to wild-card.\n          res.set(header, req.get('Origin') || '*');\n          break;\n\n        case accessControl.allowMethods:\n          if (req.swagger && req.swagger.path) {\n            // Return the allowed methods for this Swagger path\n            res.set(header, util.getAllowedMethods(req.swagger.path));\n          }\n          else {\n            // By default, allow all of the requested methods. Fallback to ALL methods.\n            res.set(header, req.get('Access-Control-Request-Method') || util.swaggerMethods.join(', ').toUpperCase());\n          }\n          break;\n\n        case accessControl.allowHeaders:\n          // By default, allow all of the requested headers\n          res.set(header, req.get('Access-Control-Request-Headers') || '');\n          break;\n\n        case accessControl.allowCredentials:\n          // By default, allow credentials\n          res.set(header, true);\n          break;\n\n        case accessControl.maxAge:\n          // By default, access-control expires immediately.\n          res.set(header, 0);\n          break;\n      }\n    }\n  });\n\n  if (res.get(accessControl.allowOrigin) === '*') {\n    // If Access-Control-Allow-Origin is wild-carded, then Access-Control-Allow-Credentials must be false\n    res.set('Access-Control-Allow-Credentials', 'false');\n  }\n  else {\n    // If Access-Control-Allow-Origin is set (not wild-carded), then \"Vary: Origin\" must be set\n    res.vary('Origin');\n  }\n\n  next();\n}\n\n/**\n * Handles CORS preflight requests.\n */\nfunction corsPreflight(req, res, next) {\n  if (req.method === 'OPTIONS') {\n    util.debug('OPTIONS %s is a CORS preflight request. Sending HTTP 200 response.', req.path);\n    res.send();\n  }\n  else {\n    next();\n  }\n}\n\n/**\n * Returns an object containing the CORS response headers that are defined in the Swagger API.\n * If the same CORS header is defined for multiple responses, then the first one wins.\n *\n * @param   {Request}   req\n * @returns {object}\n */\nfunction getResponseHeaders(req) {\n  var corsHeaders = {};\n  if (req.swagger) {\n    var headers = [];\n\n    if (req.method !== 'OPTIONS') {\n      // This isn't a preflight request, so the operation's response headers take precedence over the OPTIONS headers\n      headers = getOperationResponseHeaders(req.swagger.operation);\n    }\n\n    if (req.swagger.path) {\n      // Regardless of whether this is a preflight request, append the OPTIONS response headers\n      headers = headers.concat(getOperationResponseHeaders(req.swagger.path.options));\n    }\n\n    // Add the headers to the `corsHeaders` object.  First one wins.\n    headers.forEach(function(header) {\n      if (corsHeaders[header.name] === undefined) {\n        corsHeaders[header.name] = header.value;\n      }\n    });\n  }\n\n  return corsHeaders;\n}\n\n/**\n * Returns all response headers for the given Swagger operation, sorted by HTTP response code.\n *\n * @param   {object}    operation   The Operation object from the Swagger API\n * @returns {{responseCode: integer, name: string, value: string}[]}\n */\nfunction getOperationResponseHeaders(operation) {\n  var headers = [];\n\n  if (operation) {\n    _.each(operation.responses, function(response, responseCode) {\n      // Convert responseCode to a numeric value for sorting (\"default\" comes last)\n      responseCode = parseInt(responseCode) || 999;\n\n      _.each(response.headers, function(header, name) {\n        // We only care about headers that have a default value defined\n        if (header.default !== undefined) {\n          headers.push({\n            order: responseCode,\n            name: name.toLowerCase(),\n            value: header.default\n          });\n        }\n      });\n    });\n  }\n\n  return _.sortBy(headers, 'order');\n}\n","/home/travis/build/npmtest/node-npmtest-swagger-express-middleware/node_modules/swagger-express-middleware/lib/request-parser.js":"'use strict';\n\nmodule.exports = requestParser;\n\nvar _            = require('lodash'),\n    bodyParser   = require('body-parser'),\n    cookieParser = require('cookie-parser'),\n    multer       = require('multer');\n\n/**\n * Parses the HTTP request into useful objects.\n * This middleware populates {@link Request#params}, {@link Request#headers}, {@link Request#cookies},\n * {@link Request#signedCookies}, {@link Request#query}, {@link Request#body}, and {@link Request#files}.\n *\n * @param   {requestParser.defaultOptions}  [options]\n * @returns {function[]}\n */\nfunction requestParser(options) {\n  // Override default options\n  options = _.merge({}, requestParser.defaultOptions, options);\n\n  return [\n    cookieParser(options.cookie.secret, options.cookie),\n    bodyParser.json(options.json),\n    bodyParser.text(options.text),\n    bodyParser.urlencoded(options.urlencoded),\n    bodyParser.raw(options.raw),\n    multer(options.multipart)\n  ];\n}\n\nrequestParser.defaultOptions = {\n  /**\n   * Cookie parser options\n   * (see https://github.com/expressjs/cookie-parser#cookieparsersecret-options)\n   */\n  cookie: {\n    secret: undefined\n  },\n\n  /**\n   * JSON body parser options\n   * (see https://github.com/expressjs/body-parser#bodyparserjsonoptions)\n   */\n  json: {\n    limit: '1mb',\n    type: ['json', '*/json', '+json']\n  },\n\n  /**\n   * Plain-text body parser options\n   * (see https://github.com/expressjs/body-parser#bodyparsertextoptions)\n   */\n  text: {\n    limit: '1mb',\n    type: ['text/*']\n  },\n\n  /**\n   * URL-encoded body parser options\n   * (see https://github.com/expressjs/body-parser#bodyparserurlencodedoptions)\n   */\n  urlencoded: {\n    extended: true,\n    limit: '1mb'\n  },\n\n  /**\n   * Raw body parser options\n   * (see https://github.com/expressjs/body-parser#bodyparserrawoptions)\n   */\n  raw: {\n    limit: '5mb',\n    type: 'application/*'\n  },\n\n  /**\n   * Multipart form data parser options\n   * (see https://github.com/expressjs/multer#options)\n   */\n  multipart: {\n    putSingleFilesInArray: false // the Swagger spec does not allow multiple file params with same name\n  }\n};\n","/home/travis/build/npmtest/node-npmtest-swagger-express-middleware/node_modules/swagger-express-middleware/lib/param-parser.js":"'use strict';\n\nmodule.exports = paramParser;\nmodule.exports.parseParameter = parseParameter;\n\nvar _          = require('lodash'),\n    util       = require('./helpers/util'),\n    JsonSchema = require('./helpers/json-schema');\n\n/**\n * Parses all Swagger parameters in the HTTP request.\n * This middleware populates {@link Request#headers}, {@link Request#query}, and {@link Request#body}.\n *\n * @returns {function[]}\n */\nfunction paramParser() {\n  return [parseSimpleParams, parseFormDataParams, parseBodyParam];\n}\n\n/**\n * Parses all Swagger parameters in the query string and headers\n */\nfunction parseSimpleParams(req, res, next) {\n  var params = getParams(req);\n\n  if (params.length > 0) {\n    util.debug('Parsing %d request parameters...', params.length);\n\n    params.forEach(function(param) {\n      // Get the raw value of the parameter\n      switch (param.in) {\n        case 'query':\n          util.debug('    Parsing the \"%s\" query parameter', param.name);\n          req.query[param.name] = parseParameter(param, req.query[param.name], param);\n          break;\n        case 'header':\n          // NOTE: req.headers properties are always lower-cased\n          util.debug('    Parsing the \"%s\" header parameter', param.name);\n          req.headers[param.name.toLowerCase()] = parseParameter(param, req.header(param.name), param);\n          break;\n      }\n    });\n  }\n\n  next();\n}\n\n/**\n * Parses all Swagger parameters in the form data.\n */\nfunction parseFormDataParams(req, res, next) {\n  getParams(req).forEach(function(param) {\n    if (param.in === 'formData') {\n      util.debug('    Parsing the \"%s\" form-data parameter', param.name);\n\n      if (param.type === 'file') {\n        // Validate the file (min/max size, etc.)\n        req.files[param.name] = parseParameter(param, req.files[param.name], param);\n      }\n      else {\n        // Parse the body parameter\n        req.body[param.name] = parseParameter(param, req.body[param.name], param);\n      }\n    }\n  });\n\n  next();\n}\n\n/**\n * Parses the Swagger \"body\" parameter.\n */\nfunction parseBodyParam(req, res, next) {\n  var params = getParams(req);\n\n  params.some(function(param) {\n    if (param.in === 'body') {\n      util.debug('    Parsing the \"%s\" body parameter', param.name);\n\n      if (_.isPlainObject(req.body) && _.isEmpty(req.body)) {\n        if (param.type === 'string' || (param.schema && param.schema.type === 'string')) {\n          // Convert {} to \"\"\n          req.body = '';\n        }\n        else {\n          // Convert {} to undefined\n          req.body = undefined;\n        }\n      }\n\n      // Parse the body\n      req.body = parseParameter(param, req.body, param.schema);\n\n      // There can only be one \"body\" parameter, so skip the rest\n      return true;\n    }\n  });\n\n  // If there are no body/formData parameters, then reset `req.body` to undefined\n  if (params.length > 0) {\n    var hasBody = params.some(function(param) {\n      return param.in === 'body' || param.in === 'formData';\n    });\n\n    if (!hasBody) {\n      req.body = undefined;\n    }\n  }\n\n  next();\n}\n\n/**\n * Parses the given parameter, using the given JSON schema definition.\n *\n * @param   {object}    param   The Parameter API object\n * @param   {*}         value   The value to be parsed (it will be coerced if needed)\n * @param   {object}    schema  The JSON schema definition for the parameter\n * @returns {*}                 The parsed value\n */\nfunction parseParameter(param, value, schema) {\n  if (value === undefined) {\n    if (param.required) {\n      // The parameter is required, but was not provided, so throw a 400 error\n      var errCode = 400;\n\n      if (param.in === 'header' && param.name.toLowerCase() === 'content-length') {\n        // Special case for the Content-Length header.  It has it's own HTTP error code.\n        errCode = 411; // (Length Required)\n      }\n\n      //noinspection ExceptionCaughtLocallyJS\n      throw util.newError(errCode, 'Missing required %s parameter \"%s\"', param.in, param.name);\n    }\n    else if (schema.default === undefined) {\n      // The parameter is optional, and there's no default value\n      return undefined;\n    }\n  }\n\n  try {\n    return new JsonSchema(schema).parse(value);\n  }\n  catch (e) {\n    throw util.newError(e.status, e, 'The \"%s\" %s parameter is invalid (%j)',\n      param.name, param.in, value === undefined ? param.default : value);\n  }\n}\n\n/**\n * Returns an array of the `req.swagger.params` properties.\n *\n * @returns {object[]}\n */\nfunction getParams(req) {\n  if (req.swagger && req.swagger.params) {\n    return req.swagger.params;\n  }\n  return [];\n}\n","/home/travis/build/npmtest/node-npmtest-swagger-express-middleware/node_modules/swagger-express-middleware/lib/helpers/json-schema.js":"'use strict';\n\nmodule.exports = JsonSchema;\n\nvar tv4  = require('tv4'),\n    util = require('./util'),\n    _    = require('lodash');\n\n// Supported data types\nvar dataTypes = ['string', 'number', 'integer', 'boolean', 'array', 'object', 'file'];\n\n// Valid patterns for each data type\nvar dataTypePatterns = {\n  integer: /^[+-]?(\\d+|0x[\\dA-F]+)$/i,\n\n  date: /^\\d{4}-\\d{2}-\\d{2}$/,\n\n  'date-time': /^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?(Z|[+-]\\d{2}:\\d{2})$/i\n};\n\n// Some older versions of Node don't define these constants\nvar MIN_SAFE_INTEGER = Number.MIN_SAFE_INTEGER || -9007199254740991;\nvar MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER || 9007199254740991;\nvar MAX_VALUE = Number.MAX_VALUE || 1.7976931348623157e+308;\nvar MIN_VALUE = -MAX_VALUE;\nvar EPSILON = Number.EPSILON || 2.220446049250313e-16;\n\n// Numeric type ranges\nvar ranges = {\n  int32: {\n    min: -2147483648,\n    max: 2147483647\n  },\n\n  int64: {\n    min: MIN_SAFE_INTEGER,\n    max: MAX_SAFE_INTEGER\n  },\n\n  byte: {\n    min: 0,\n    max: 255\n  },\n\n  float: {\n    min: -3.402823e38,\n    max: 3.402823e38\n  },\n\n  double: {\n    min: MIN_VALUE,\n    max: MAX_VALUE\n  }\n};\n\n/**\n * Parses and validates values against JSON schemas.\n * @constructor\n */\nfunction JsonSchema(schema) {\n  if (!schema) {\n    throw util.newError('Missing JSON schema');\n  }\n  if (schema.type !== undefined && dataTypes.indexOf(schema.type) === -1) {\n    throw util.newError('Invalid JSON schema type: %s', schema.type);\n  }\n\n  this.schema = schema;\n}\n\n/**\n * Parses the given value according to the schema.\n * An error is thrown if the value is invalid.\n *\n * @param   {*}         value           The value to be parsed against the schema\n * @param   {string}    [propPath]      Used only for logging and error messages (e.g. \"person.address.city\")\n * @returns {*}                         The valid, parsed value\n */\nJsonSchema.prototype.parse = function(value, propPath) {\n  switch (this.schema.type) {\n    case 'number':\n      return parseNumber(this.schema, value, propPath);\n    case 'integer':\n      return parseInteger(this.schema, value, propPath);\n    case 'boolean':\n      return parseBoolean(this.schema, value, propPath);\n    case 'array':\n      return parseArray(this.schema, value, propPath);\n    case 'object':\n    case undefined:\n      return parseObject(this.schema, value, propPath);\n    case 'file':\n      return parseFile(this.schema, value, propPath);\n    case 'string':\n      switch (this.schema.format) {\n        case 'byte':\n          return parseInteger(this.schema, value, propPath);\n        case 'date':\n        case 'date-time':\n          return parseDate(this.schema, value, propPath);\n        default:\n          return parseString(this.schema, value, propPath);\n      }\n  }\n};\n\n/**\n * Serializes the given value according to the schema.\n * An error is thrown if the value is invalid.\n *\n * @param   {*}         value           The value to be serialized.\n * @param   {string}    [propPath]      Used only for logging and error messages (e.g. \"person.address.city\")\n * @returns {*}                         The serialized value, suitable for persisting or transmitting\n */\nJsonSchema.prototype.serialize = function(value, propPath) {\n  switch (this.schema.type) {\n    case 'number':\n      return serializeNumber(this.schema, value, propPath);\n    case 'integer':\n      return serializeInteger(this.schema, value, propPath);\n    case 'boolean':\n      return serializeBoolean(this.schema, value, propPath);\n    case 'array':\n      return serializeArray(this.schema, value, propPath);\n    case 'object':\n    case undefined:\n      return serializeObject(this.schema, value, propPath);\n    case 'file':\n      return serializeFile(this.schema, value, propPath);\n    case 'string':\n      switch (this.schema.format) {\n        case 'byte':\n          return serializeInteger(this.schema, value, propPath);\n        case 'date':\n        case 'date-time':\n          return serializeDate(this.schema, value, propPath);\n        default:\n          return serializeString(this.schema, value, propPath);\n      }\n  }\n};\n\n/**\n * Generates sample data from the schema.\n *\n * @returns {*}\n */\nJsonSchema.prototype.sample = function() {\n  switch (this.schema.type) {\n    case 'number':\n      return sampleNumber(this.schema);\n    case 'integer':\n      return sampleInteger(this.schema);\n    case 'boolean':\n      return sampleBoolean(this.schema);\n    case 'array':\n      return sampleArray(this.schema);\n    case 'object':\n    case undefined:\n      return sampleObject(this.schema);\n    case 'string':\n      switch (this.schema.format) {\n        case 'byte':\n          return sampleInteger(this.schema);\n        case 'date':\n        case 'date-time':\n          return sampleDate(this.schema);\n        default:\n          return sampleString(this.schema);\n      }\n  }\n};\n\n/**\n * Returns the given value, or the default value if the given value is empty.\n */\nfunction getValueToValidate(schema, value) {\n  // Is the value empty?\n  if (value === undefined || value === '' ||\n    (schema.type === 'object' && _.isObject(value) && _.isEmpty(value))) {\n\n    // It's blank, so return the default/example value (if there is one)\n    if (schema.default !== undefined) {\n      value = schema.default;\n    }\n    else if (schema.example !== undefined) {\n      value = schema.example;\n    }\n  }\n\n  // Special case for Buffers\n  if (value && value.type === 'Buffer' && _.isArray(value.data)) {\n    value = new Buffer(value.data);\n  }\n\n  // It's not empty, so return the existing value\n  return value;\n}\n\nfunction jsonValidate(schema, value, propPath) {\n  if (tv4.validate(value, schema)) {\n    return true;\n  }\n  else if (propPath !== undefined) {\n    var dataPath = propPath ? propPath + '.' + tv4.error.dataPath : tv4.error.dataPath;\n    throw util.newError(400, tv4.error, 'JSON Schema validation error. \\nData path: \"%s\" \\nSchema path: \"%s\"',\n      dataPath, tv4.error.schemaPath);\n  }\n  else {\n    throw util.newError(400, tv4.error, 'JSON Schema validation error.');\n  }\n}\n\nfunction parseInteger(schema, value, propPath) {\n  // Handle missing, required, and default\n  value = getValueToValidate(schema, value);\n\n  // Make sure it's a properly-formatted integer\n  var parsedValue = parseInt(value);\n  if (_.isNaN(parsedValue) || !_.isFinite(parsedValue) || !dataTypePatterns.integer.test(value)) {\n    throw util.newError(400, '\"%s\" is not a properly-formatted whole number', propPath || value);\n  }\n\n  // Force the schema to be validated as an integer\n  var originalType = schema.type;\n  schema.type = 'integer';\n\n  // Validate against the schema\n  try {\n    jsonValidate(schema, parsedValue, propPath);\n  }\n  finally {\n    // Restore the original schema type\n    schema.type = originalType;\n  }\n\n  // Validate the format\n  var range = ranges[schema.format];\n  if (range) {\n    if (parsedValue < range.min || parsedValue > range.max) {\n      throw util.newError(400, '\"%s\" is not a valid %s. Must be between %d and %d',\n        propPath || parsedValue, schema.format, range.min, range.max);\n    }\n  }\n\n  return parsedValue;\n}\n\nfunction serializeInteger(schema, value, propPath) {\n  value = getValueToValidate(schema, value);\n  if (value !== undefined) {\n    return parseInt(value);\n  }\n}\n\nfunction sampleInteger(schema) {\n  var min, max;\n  if (schema.minimum !== undefined) {\n    min = parseInt(schema.minimum) + (schema.exclusiveMinimum ? 1 : 0);\n  }\n  else {\n    min = Math.min(1, schema.maximum - 1) || 1;\n  }\n\n  if (schema.maximum !== undefined) {\n    max = parseInt(schema.maximum) - (schema.exclusiveMaximum ? 1 : 0);\n  }\n  else {\n    max = (ranges[schema.format] || ranges.int64).max;\n  }\n\n  return _.random(min, max);\n}\n\nfunction parseNumber(schema, value, propPath) {\n  // Handle missing, required, and default\n  value = getValueToValidate(schema, value);\n\n  // Make sure it's a properly-formatted number\n  var parsedValue = parseFloat(value);\n  if (_.isNaN(parsedValue) || !_.isFinite(parsedValue)) {\n    throw util.newError(400, '\"%s\" is not a valid numeric value', propPath || value);\n  }\n\n  // Validate against the schema\n  jsonValidate(schema, parsedValue, propPath);\n\n  // Validate the format\n  var range = ranges[schema.format];\n  if (range) {\n    if (parsedValue < range.min || parsedValue > range.max) {\n      throw util.newError(400, '\"%s\" is not a valid %s. Must be between %d and %d',\n        propPath || value, schema.format, range.min, range.max);\n    }\n  }\n\n  return parsedValue;\n}\n\nfunction serializeNumber(schema, value, propPath) {\n  value = getValueToValidate(schema, value);\n  if (value !== undefined) {\n    return parseFloat(value);\n  }\n}\n\nfunction sampleNumber(schema) {\n  var min, max;\n  if (schema.minimum !== undefined) {\n    min = parseFloat(schema.minimum) + (schema.exclusiveMinimum ? EPSILON : 0);\n  }\n  else {\n    min = Math.min(0, schema.maximum) || 0;\n  }\n\n  if (schema.maximum !== undefined) {\n    max = parseFloat(schema.maximum) - (schema.exclusiveMaximum ? EPSILON : 0);\n  }\n  else {\n    max = (ranges[schema.format] || ranges.double).max;\n  }\n\n  return _.random(min, max);\n}\n\nfunction parseBoolean(schema, value, propPath) {\n  // Handle missing, required, and default\n  value = getValueToValidate(schema, value);\n\n  // \"Parse\" the value\n  var parsedValue = value;\n  var stringValue = _(value).toString().toLowerCase();\n  if (stringValue === 'true') {\n    parsedValue = true;\n  }\n  else if (stringValue === 'false') {\n    parsedValue = false;\n  }\n\n  // Validate against the schema\n  jsonValidate(schema, parsedValue, propPath);\n\n  return !!parsedValue;\n}\n\nfunction serializeBoolean(schema, value, propPath) {\n  value = getValueToValidate(schema, value);\n  if (value !== undefined) {\n    return !!value;\n  }\n}\n\nfunction sampleBoolean(schema) {\n  return _.random() % 2 === 0;\n}\n\nfunction parseString(schema, value, propPath) {\n  // Handle missing, required, and default\n  value = getValueToValidate(schema, value);\n\n  // Validate against the schema\n  jsonValidate(schema, value, propPath);\n\n  return value;\n}\n\nfunction serializeString(schema, value, propPath) {\n  value = getValueToValidate(schema, value);\n  if (value !== undefined) {\n    return _(value).toString();\n  }\n}\n\nfunction sampleString(schema) {\n  var minLength, maxLength;\n  if (schema.minLength !== undefined) {\n    minLength = parseInt(schema.minLength);\n  }\n  else {\n    minLength = Math.min(1, schema.maxLength) || 1;\n  }\n\n  if (schema.maxLength !== undefined) {\n    maxLength = parseInt(schema.maxLength);\n  }\n  else {\n    maxLength = Math.max(50, minLength);\n  }\n\n  var charSet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';\n  var str = '';\n  var length = _.random(minLength, maxLength);\n  for (var i = 0; i < length; i++) {\n    str += charSet[_.random(0, charSet.length - 1)];\n  }\n\n  return str;\n}\n\nfunction parseArray(schema, value, propPath) {\n  // Handle missing, required, and default\n  value = getValueToValidate(schema, value);\n\n  var parsedValue = value;\n\n  if (_.isString(value) && value.length) {\n    // Parse the string to an array\n    switch (schema.collectionFormat) {\n      case 'ssv':\n        parsedValue = value.split(' ');\n        break;\n      case 'tsv':\n        parsedValue = value.split('\\t');\n        break;\n      case 'pipes':\n        parsedValue = value.split('|');\n        break;\n      default: // csv\n        parsedValue = value.split(',');\n    }\n  }\n\n  if (schema.items.type === 'string') {\n    // Validate the array against the schema BEFORE parsing the items\n    jsonValidate(schema, parsedValue, propPath);\n  }\n\n  // Parse the items in the array\n  parseArrayItems(schema, parsedValue, propPath);\n\n  if (schema.items.type !== 'string') {\n    // Validate the array against the schema AFTER parsing the items\n    jsonValidate(schema, parsedValue, propPath);\n  }\n\n  return parsedValue;\n}\n\nfunction parseArrayItems(schema, array, propPath) {\n  var itemSchema = new JsonSchema(schema.items);\n\n  for (var i = 0; i < array.length; i++) {\n    var item = array[i];\n    try {\n      array[i] = itemSchema.parse(item, propPath + '[' + i + ']');\n    }\n    catch (e) {\n      throw util.newError(400, e, 'Unable to parse %s item at index %d (%j).', propPath || 'array', i, item);\n    }\n  }\n}\n\nfunction serializeArray(schema, value, propPath) {\n  value = getValueToValidate(schema, value);\n\n  if (_.isArray(value) && schema.items) {\n    var itemSchema = new JsonSchema(schema.items);\n\n    for (var i = 0; i < value.length; i++) {\n      value[i] = itemSchema.serialize(value[i], propPath + '[' + i + ']');\n    }\n  }\n\n  return value;\n}\n\nfunction sampleArray(schema) {\n  var minItems, maxItems;\n  if (schema.minItems !== undefined) {\n    minItems = parseInt(schema.minItems);\n  }\n  else {\n    minItems = Math.min(1, schema.maxItems || 1);\n  }\n\n  if (schema.maxItems !== undefined) {\n    maxItems = parseInt(schema.maxItems);\n  }\n  else {\n    maxItems = Math.max(50, minItems);\n  }\n\n  var array = [];\n  var itemSchema = new JsonSchema(schema.items);\n  var length = _.random(minItems, maxItems);\n  for (var i = 0; i < length; i++) {\n    array.push(itemSchema.sample());\n  }\n\n  return array;\n}\n\nfunction parseObject(schema, value, propPath) {\n  // Handle missing, required, and default\n  value = getValueToValidate(schema, value);\n\n  // Parse the value\n  var parsedValue = value;\n  if (_.isString(value) && value.length) {\n    parsedValue = JSON.parse(value);\n  }\n\n  // Validate against the schema\n  jsonValidate(schema, parsedValue, propPath || '');\n\n  // Recursively parse the object's properties\n  _.forEach(schema.properties, function(prop, propName) {\n    if (parsedValue[propName] !== undefined || prop.default !== undefined) {\n      var propSchema = new JsonSchema(prop);\n      var fullPropPath = propPath ? propPath + '.' + propName : propName;\n      parsedValue[propName] = propSchema.parse(parsedValue[propName], fullPropPath);\n    }\n  });\n\n  return parsedValue;\n}\n\nfunction serializeObject(schema, value, propPath) {\n  value = getValueToValidate(schema, value);\n\n  if (value) {\n    _.forEach(schema.properties, function(prop, propName) {\n      var propSchema = new JsonSchema(prop);\n      var fullPropPath = propPath ? propPath + '.' + propName : propName;\n      var propValue = propSchema.serialize(value[propName], fullPropPath);\n      if (propValue !== undefined) {\n        value[propName] = propValue;\n      }\n    });\n  }\n\n  return value;\n}\n\nfunction sampleObject(schema) {\n  var obj = {};\n  _.keys(schema.properties).forEach(function(propName) {\n    var propSchema = new JsonSchema(schema.properties[propName]);\n    obj[propName] = propSchema.sample();\n  });\n\n  return obj;\n}\n\nfunction parseFile(schema, value, propPath) {\n  // Handle missing, required, and default\n  value = getValueToValidate(schema, value);\n\n  // Parse the value\n  var parsedValue = value;\n  if (!_.isObject(parsedValue) || !_.has(parsedValue, 'size')) {\n    throw util.newError(400, '%s is invalid or corrupted', propPath || 'File');\n  }\n\n  // Validate minLength and maxLength\n  if (schema.minLength) {\n    var minLength = parseInt(schema.minLength);\n    if (isNaN(minLength)) {\n      throw util.newError('The \"minLength\" value in the Swagger API is invalid (%j)', schema.minLength);\n    }\n\n    if (parsedValue.size < minLength) {\n      throw util.newError(400, '%s \"%s\" is only %d bytes. The minimum is %d bytes',\n        propPath || 'File', parsedValue.originalname, parsedValue.size, minLength);\n    }\n  }\n\n  if (schema.maxLength) {\n    var maxLength = parseInt(schema.maxLength);\n    if (isNaN(maxLength)) {\n      throw util.newError('The \"maxLength\" value in the Swagger API is invalid (%j)', schema.maxLength);\n    }\n\n    if (parsedValue.size > maxLength) {\n      throw util.newError(413, '%s \"%s\" is %d bytes. The maximum is %d bytes',\n        propPath || 'File', parsedValue.originalname, parsedValue.size, maxLength);\n    }\n  }\n\n  return parsedValue;\n}\n\nfunction serializeFile(schema, value, propPath) {\n  value = getValueToValidate(schema, value);\n\n  // Search for a property that looks like a File object\n  var keys = _.keys(value);\n  for (var i = 0; i < keys.length; i++) {\n    var file = value[keys[i]];\n    if (file && file.path && _.isString(file.path)) {\n      // This is the File object, so return it\n      return file;\n    }\n  }\n\n  // None of the properties was a File object, so assume that the value itself is the file object\n  return value;\n}\n\nfunction parseDate(schema, value, propPath) {\n  var parsedValue;\n\n  // Handle missing, required, and default\n  value = getValueToValidate(schema, value);\n\n  // If the value is already a Date, then we can skip some validation\n  if (_.isDate(value)) {\n    parsedValue = value;\n  }\n  else {\n    // Validate against the schema\n    jsonValidate(schema, value, propPath);\n\n    // Validate the format\n    var formatPattern = dataTypePatterns[schema.format];\n    if (!formatPattern.test(value)) {\n      throw util.newError(400, '\"%s\" is not a properly-formatted %s', propPath || value, schema.format);\n    }\n\n    // Parse the date\n    parsedValue = new Date(value);\n    if (!parsedValue || isNaN(parsedValue.getTime())) {\n      throw util.newError(400, '\"%s\" is an invalid %s', propPath || value, schema.format);\n    }\n  }\n\n  if (schema.minimum) {\n    var minDate = new Date(schema.minimum);\n    if (isNaN(minDate.getTime())) {\n      throw util.newError('The \"minimum\" value in the Swagger API is invalid (%j)', schema.minimum);\n    }\n\n    if (parsedValue < minDate) {\n      throw util.newError(400, '%s (%j) is less than minimum %j', propPath || 'Value', parsedValue, minDate);\n    }\n\n    if (schema.exclusiveMinimum === true) {\n      if (parsedValue.getTime() === minDate.getTime()) {\n        throw util.newError(400, '%s (%j) is equal to exclusive minimum %j', propPath || 'Value', parsedValue, minDate);\n      }\n    }\n  }\n\n  if (schema.maximum) {\n    var maxDate = new Date(schema.maximum);\n    if (isNaN(maxDate.getTime())) {\n      throw util.newError('The \"maximum\" value in the Swagger API is invalid (%j)', schema.maximum);\n    }\n\n    if (parsedValue > maxDate) {\n      throw util.newError(400, '%s (%j) is greater than maximum %j', propPath || 'Value', parsedValue, maxDate);\n    }\n\n    if (schema.exclusiveMaximum === true) {\n      if (parsedValue.getTime() === maxDate.getTime()) {\n        throw util.newError(400, '%s (%j) is equal to exclusive maximum %j', propPath || 'Value', parsedValue, maxDate);\n      }\n    }\n  }\n\n  return parsedValue;\n}\n\nfunction serializeDate(schema, value, propPath) {\n  value = getValueToValidate(schema, value);\n\n  if (schema.format === 'date' && value) {\n    // This works regardless of whether the value is a Date or an ISO8601 string\n    return JSON.stringify(value).substring(1, 11);\n  }\n  else if (_.isDate(value)) {\n    return value.toJSON();\n  }\n  else if (value) {\n    return _(value).toString();\n  }\n}\n\nfunction sampleDate(schema) {\n  var min, max;\n  if (schema.minimum !== undefined) {\n    min = parseInt(new Date(schema.minimum).valueOf()) + (schema.exclusiveMinimum ? 1 : 0);\n  }\n  else {\n    min = Date.UTC(1970, 0, 1);\n    min = Math.min(min, new Date(schema.maximum).valueOf()) || min;\n  }\n\n  if (schema.maximum !== undefined) {\n    max = parseInt(new Date(schema.maximum).valueOf()) - (schema.exclusiveMaximum ? 1 : 0);\n  }\n  else {\n    max = Math.max(Date.now(), min);\n  }\n\n  var date = new Date(_.random(min, max));\n\n  if (schema.format === 'date') {\n    // Only return the year/month/day (in UTC)\n    date = new Date(Date.UTC(date.getUTCFullYear(), date.getUTCMonth(), date.getUTCDate()));\n  }\n\n  return date;\n}\n","/home/travis/build/npmtest/node-npmtest-swagger-express-middleware/node_modules/swagger-express-middleware/lib/path-parser.js":"'use strict';\n\nmodule.exports = pathParser;\n\nvar _           = require('lodash'),\n    util        = require('./helpers/util'),\n    paramParser = require('./param-parser');\n\n/**\n * Parses Swagger path parameters in the HTTP request.\n * This middleware populates {@link Request#params} and {@link Request#pathParams}.\n *\n * NOTE: Express uses a special type of middleware for parsing path parameters.\n * This middleware must be registered using {@link Router#param} rather than {@link Router#use}, {@link Router#get}, etc.\n * In addition, path-parsing middleware must be registered for EACH path parameter in the Swagger API.\n * See http://expressjs.com/4x/api.html#router.param for more info.\n *\n * @param   {MiddlewareContext}    context\n * @param   {express#Router}       [router]\n * @returns {function[]}\n */\nfunction pathParser(context, router) {\n  router = util.isExpressRouter(router) ? router : context.router;\n\n  if (util.isExpressRouter(router)) {\n    // This is special path-param middleware, which sets `req.params`\n    registerPathParamMiddleware();\n\n    // If the API changes, register any new path-params\n    context.on('change', registerPathParamMiddleware);\n  }\n  else {\n    util.debug(\n      'WARNING! An Express Router/Application was not passed to the requestParser middleware. ' +\n      'req.params will not be parsed. Use req.pathParams instead.'\n    );\n  }\n\n  // This is normal middleware, which sets `req.pathParams`\n  return [parsePathParams];\n\n  /**\n   * Registers middleware to parse path parameters.\n   */\n  function registerPathParamMiddleware() {\n    var pathParams = getAllPathParamNames();\n\n    pathParams.forEach(function(param) {\n      if (!alreadyRegistered(param)) {\n        router.param(param, pathParamMiddleware);\n      }\n    });\n  }\n\n  /**\n   * Returns the unique names of all path params in the Swagger API.\n   *\n   * @returns {string[]}\n   */\n  function getAllPathParamNames() {\n    var params = [];\n\n    function addParam(param) {\n      if (param.in === 'path') {\n        params.push(param.name);\n      }\n    }\n\n    if (context.api) {\n      _.each(context.api.paths, function(path) {\n        // Add each path parameter\n        _.each(path.parameters, addParam);\n\n        // Add each operation parameter\n        _.each(path, function(operation) {\n          _.each(operation.parameters, addParam);\n        });\n      });\n    }\n\n    return _.unique(params);\n  }\n\n  /**\n   * Determines whether we've already registered path-param middleware for the given parameter.\n   *\n   * @param   {string}    paramName\n   * @returns {boolean}\n   */\n  function alreadyRegistered(paramName) {\n    var params = router.params;\n    if (!params && router._router) {\n      params = router._router.params;\n    }\n\n    return params && params[paramName] &&\n      (params[paramName].indexOf(pathParamMiddleware) >= 0);\n  }\n\n  /**\n   * This is a special type of Express middleware that specifically parses path parameters and sets `req.params`.\n   * See http://expressjs.com/4x/api.html#router.param\n   */\n  function pathParamMiddleware(req, res, next, value, name) {\n    if (req.pathParams) {\n      // Path parameters have already been parsed by\n      req.params[name] = req.pathParams[name] || req.params[name];\n    }\n\n    next();\n  }\n\n  /**\n   * Parses all Swagger path parameters and sets `req.pathParams`.\n   * NOTE: This middleware cannot set `req.params`.  That requires special path-param middleware (see above)\n   */\n  function parsePathParams(req, res, next) {\n    if (util.isSwaggerRequest(req)) {\n      req.pathParams = {};\n\n      if (req.swagger.pathName.indexOf('{') >= 0) {\n        // Convert the Swagger path to a RegExp\n        var paramNames = [];\n        var pathPattern = req.swagger.pathName.replace(util.swaggerParamRegExp, function(match, paramName) {\n          paramNames.push(paramName);\n          return '([^\\/]+)';\n        });\n\n        // Exec the RegExp to get the path param values from the URL\n        var values = new RegExp(pathPattern + '\\/?$', 'i').exec(req.path);\n\n        // Parse each path param\n        for (var i = 1; i < values.length; i++) {\n          var paramName = paramNames[i - 1];\n          var paramValue = decodeURIComponent(values[i]);\n          var param = _.find(req.swagger.params, {in: 'path', name: paramName});\n\n          util.debug('    Parsing the \"%s\" path parameter', paramName);\n          req.pathParams[paramName] = paramParser.parseParameter(param, paramValue, param);\n        }\n      }\n    }\n\n    next();\n  }\n}\n","/home/travis/build/npmtest/node-npmtest-swagger-express-middleware/node_modules/swagger-express-middleware/lib/request-validator.js":"'use strict';\n\nmodule.exports = requestValidator;\n\nvar util = require('./helpers/util'),\n    _    = require('lodash');\n\n/**\n * Validates the HTTP request against the Swagger API.\n * An error is sent downstream if the request is invalid for any reason.\n *\n * @param   {MiddlewareContext}    context\n * @returns {function[]}\n */\nfunction requestValidator(context) {\n  return [http500, http401, http404, http405, http406, http413, http415];\n\n  /**\n   * Throws an HTTP 500 error if the Swagger API is invalid.\n   * Calling {@link Middleware#init} again with a valid Swagger API will clear the error.\n   */\n  function http500(req, res, next) {\n    if (context.error) {\n      context.error.status = 500;\n      throw context.error;\n    }\n\n    next();\n  }\n}\n\n/**\n * If the Swagger API requires security for the request, and the request doesn't contain the necessary security info,\n * then an HTTP 401 (Unauthorized) is thrown, and the WWW-Authenticate header is set.\n * NOTE: This does not perform any authentication or authorization. It simply verifies that authentication info is present.\n */\nfunction http401(req, res, next) {\n  if (util.isSwaggerRequest(req) && req.swagger.security.length > 0) {\n    var securityTypes = [];\n\n    util.debug('Validating security requirements');\n\n    // Loop through each Security Requirement (if ANY of them are met, then the request is valid)\n    var isValid = req.swagger.security.some(function(requirement) {\n      var securityDefinitions = _.map(requirement, function(scopes, name) {\n        return req.swagger.api.securityDefinitions[name];\n      });\n\n      // Loop through each Security Definition (if ALL of them are met, then the request is valid)\n      return securityDefinitions.every(function(securityDef) {\n        if (securityTypes.indexOf(securityDef.type) === -1) {\n          securityTypes.push(securityDef.type);\n        }\n\n        if (securityDef.type === 'basic') {\n          return _.startsWith(req.header('Authorization'), 'Basic ');\n        }\n        else if (securityDef.type === 'apiKey' && securityDef.in === 'header') {\n          return req.header(securityDef.name) !== undefined;\n        }\n        else if (securityDef.type === 'apiKey' && securityDef.in === 'query') {\n          return req.query[securityDef.name] !== undefined;\n        }\n        else {\n          // For any other type of security, just assume it's valid.\n          // TODO: Is there a way to validate OAuth2 here?\n          return true;\n        }\n      });\n    });\n\n    if (!isValid) {\n      securityTypes = securityTypes.join(', ');\n      util.debug(\n        'The client didn\\'t provide authentication information for any of the required authentication types (%s). ' +\n        'Returning HTTP 401 (Unauthorized)', securityTypes\n      );\n      res.set('WWW-Authenticate', 'Basic realm=\"' + (req.hostname || 'server') + '\"');\n      throw util.newError(401, '%s %s requires authentication (%s)', req.method, req.path, securityTypes);\n    }\n  }\n\n  next();\n}\n\n/**\n * If the request is under the Swagger API's basePath, but no matching Path was found,\n * then an HTTP 404 (Not Found) error is thrown\n */\nfunction http404(req, res, next) {\n  if (req.swagger && req.swagger.api && !req.swagger.path) {\n    util.debug(\n      'Client requested path \"%s\", which is not defined in the Swagger API. Returning HTTP 404 (Not Found)',\n      req.path\n    );\n    throw util.newError(404, 'Resource not found: %s', req.path);\n  }\n\n  next();\n}\n\n/**\n * If the Swagger Path was matched, but the HTTP method doesn't match any of the Swagger Operations,\n * then an HTTP 405 (Method Not Allowed) error is thrown, and the \"Allow\" header is set to the list of valid methods\n */\nfunction http405(req, res, next) {\n  if (req.swagger && req.swagger.path && !req.swagger.operation) {\n    util.debug(\n      'Client attempted a %s operation on \"%s\", which is not allowed by the Swagger API. ' +\n      'Returning HTTP 405 (Method Not Allowed)',\n      req.method, req.path\n    );\n\n    // Let the client know which methods are allowed\n    var allowedList = util.getAllowedMethods(req.swagger.path);\n    res.set('Allow', allowedList);\n\n    throw util.newError(405, '%s does not allow %s. \\nAllowed methods: %s',\n      req.path, req.method, allowedList);\n  }\n\n  next();\n}\n\n/**\n * If the Swagger API specifies the MIME types that this operation produces,\n * and the HTTP Accept header does not match any of those MIME types, then an HTTP 406 (Not Acceptable) is thrown.\n */\nfunction http406(req, res, next) {\n  if (util.isSwaggerRequest(req)) {\n    // Get the MIME types that this operation produces\n    var produces = req.swagger.operation.produces || req.swagger.api.produces || [];\n\n    if (produces.length > 0) {\n      util.debug('Validating Accept header (%s)', req.get('Accept'));\n\n      if (!req.accepts(produces)) {\n        var accepts = req.accepts();\n        util.debug(\n          'The %s operation on \"%s\" only produces %j content, but the client requested %j. ' +\n          'Returning HTTP 406 (Not Acceptable)',\n          req.method, req.path, produces, accepts\n        );\n        throw util.newError(406, '%s %s cannot produce any of the requested formats (%s). \\nSupported formats: %s',\n          req.method, req.path, accepts.join(', '), produces.join(', '));\n      }\n    }\n  }\n\n  next();\n}\n\n/**\n * Throws an HTTP 413 (Request Entity Too Large) if the HTTP request includes\n * body content that is not allowed by the Swagger API.\n */\nfunction http413(req, res, next) {\n  if (util.isSwaggerRequest(req)) {\n    // Determine if the request allows body content\n    var bodyAllowed = req.swagger.params.some(function(param) {\n      return param.in === 'body' || param.in === 'formData';\n    });\n\n    if (!bodyAllowed) {\n      // NOTE: We used to also check the Transfer-Encoding header, but that fails in Node 0.10.x\n      // TODO: Once we drop support for Node 0.10.x, add a Transfer-Encoding check (via typeIs.hasBody())\n      var length = req.get('Content-Length');\n      util.debug('Validating Content-Length header (%d)', length);\n\n      // NOTE: Even a zero-byte file attachment will have a Content-Length > 0\n      if (length > 0) {\n        util.debug(\n          'The HTTP request contains body content, but the %s operation on \"%s\" does not allow a request body. ' +\n          'Returning HTTP 413 (Request Entity Too Large)',\n          req.method, req.path\n        );\n        throw util.newError(413, '%s %s does not allow body content', req.method, req.path);\n      }\n    }\n  }\n\n  next();\n}\n\n/**\n * Validates the HTTP Content-Type header against the Swagger API's \"consumes\" MIME types,\n * and throws an HTTP 415 (Unsupported Media Type) if there's a conflict.\n */\nfunction http415(req, res, next) {\n  if (util.isSwaggerRequest(req)) {\n    // Only validate the Content-Type if there's body content\n    if (!_.isEmpty(req.body)) {\n      // Get the MIME types that this operation consumes\n      var consumes = req.swagger.operation.consumes || req.swagger.api.consumes || [];\n\n      if (consumes.length > 0) {\n        util.debug('Validating Content-Type header (%s)', req.get('Content-Type'));\n\n        if (!req.is(consumes)) {\n          var contentType = req.header('Content-Type');\n          util.debug(\n            'Client attempted to send %s data to the %s operation on \"%s\", which is not allowed by the Swagger API. ' +\n            'Returning HTTP 415 (Unsupported Media Type)',\n            contentType, req.method, req.path\n          );\n          throw util.newError(415, '%s %s does not allow Content-Type \"%s\". \\nAllowed Content-Types: %s',\n            req.method, req.path, contentType, consumes.join(', '));\n        }\n      }\n    }\n  }\n\n  next();\n}\n\n","/home/travis/build/npmtest/node-npmtest-swagger-express-middleware/node_modules/swagger-express-middleware/lib/mock/index.js":"'use strict';\n\nmodule.exports = mock;\n\nvar _                = require('lodash'),\n    path             = require('path'),\n    fs               = require('fs'),\n    typeIs           = require('type-is'),\n    util             = require('../helpers/util'),\n    JsonSchema       = require('../helpers/json-schema'),\n    DataStore        = require('../data-store'),\n    MemoryDataStore  = require('../data-store/memory-data-store'),\n    SemanticRequest  = require('./semantic-request'),\n    SemanticResponse = require('./semantic-response'),\n    editResource     = require('./edit-resource'),\n    queryResource    = require('./query-resource'),\n    editCollection   = require('./edit-collection'),\n    queryCollection  = require('./query-collection');\n\n/**\n * Implements mock behavior for HTTP requests, based on the Swagger API.\n *\n * @param   {MiddlewareContext} context\n * @param   {express#Router}    [router]\n * @param   {DataStore}         [dataStore]\n * @returns {function[]}\n */\nfunction mock(context, router, dataStore) {\n  router = router || context.router;\n  dataStore = (dataStore instanceof DataStore) ? dataStore : new MemoryDataStore();\n  var isDisabled = _.noop;\n\n  if (util.isExpressApp(router)) {\n    // Store the DataStore as an Express setting, so it can be accessed/changed by third-party code\n    if (!(router.get('mock data store') instanceof DataStore)) {\n      router.set('mock data store', dataStore);\n    }\n\n    // Allow the mock to be disabled using `router.disable(\"mock\")`\n    isDisabled = function() {\n      return router.get('mock') === false;\n    };\n  }\n\n  return [\n    mockResponse, mockImplementation, mockResponseHeaders, mockResponseBody\n  ];\n\n  /**\n   * Determines the best Response object for this request and sets `res.swagger` to a {@link SemanticRequest} object.\n   * Also sets `res.statusCode` if it isn't already set.\n   */\n  function mockResponse(req, res, next) {\n    if (util.isSwaggerRequest(req) && !isDisabled()) {\n      var response;\n\n      // Is there already a statusCode? (perhaps set by third-party middleware)\n      if (res.statusCode && req.swagger.operation.responses[res.statusCode]) {\n        util.debug('Using %s response for %s %s', res.statusCode, req.method, req.path);\n        response = req.swagger.operation.responses[res.statusCode];\n      }\n      else {\n        // Use the first response with a 2XX or 3XX code (or \"default\")\n        var responses = util.getResponsesBetween(req.swagger.operation, 200, 399);\n        if (responses.length > 0) {\n          response = responses[0].api;\n\n          // Set the response status code\n          if (_.isNumber(responses[0].code)) {\n            util.debug('Using %s response for %s %s', responses[0].code, req.method, req.path);\n            res.status(responses[0].code);\n          }\n          else {\n            if (req.method === 'POST' || req.method === 'PUT') {\n              res.status(201);\n            }\n            else if (req.method === 'DELETE' && !responses[0].api.schema) {\n              res.status(204);\n            }\n            else {\n              res.status(200);\n            }\n            util.debug('Using %s (%d) response for %s %s', responses[0].code, res.statusCode, req.method, req.path);\n          }\n        }\n        else {\n          // There is no response with a 2XX or 3XX code, so just use the first one\n          var keys = Object.keys(req.swagger.operation.responses);\n          util.debug('Using %s response for %s %s', keys[0], req.method, req.path);\n          response = req.swagger.operation.responses[keys[0]];\n          res.status(parseInt(keys[0]));\n        }\n      }\n\n      // The rest of the Mock middleware will use this ResponseMetadata object\n      res.swagger = new SemanticResponse(response, req.swagger.path);\n    }\n\n    next();\n  }\n\n  /**\n   * Runs the appropriate mock implementation.\n   */\n  function mockImplementation(req, res, next) {\n    if (res.swagger) {\n      // Determine the semantics of this request\n      var request = new SemanticRequest(req);\n\n      // Determine which mock to run\n      var mock;\n      if (request.isCollection) {\n        mock = queryCollection[req.method] || editCollection[req.method];\n      } else {\n        mock = queryResource[req.method] || editResource[req.method];\n      }\n\n      // Get the current DataStore (this can be changed at any time by third-party code)\n      var db = util.isExpressApp(router) ? router.get('mock data store') || dataStore : dataStore;\n      db.__router = router;\n\n      // Run the mock\n      util.debug('Running the %s mock', mock.name);\n      mock(req, res, next, db);\n    }\n    else {\n      next();\n    }\n  }\n}\n\n/**\n * Sets response headers, according to the Swagger API.\n */\nfunction mockResponseHeaders(req, res, next) {\n  if (res.swagger) {\n    util.debug('Setting %d response headers...', _.keys(res.swagger.headers).length);\n\n    if (res.swagger.headers) {\n      _.forEach(res.swagger.headers, function(header, name) {\n        // Set all HTTP headers that are defined in the Swagger API.\n        // If a default value is specified in the Swagger API, then use it; otherwise generate a value.\n        if (res.get(name) !== undefined) {\n          util.debug('    %s: %s (already set)', name, res.get(name));\n        }\n        else if (header.default !== undefined) {\n          res.set(name, header.default);\n          util.debug('    %s: %s (default)', name, header.default);\n        }\n        else {\n          switch (name.toLowerCase()) {\n            case 'location':\n              res.location(req.baseUrl + (res.swagger.location || req.path));\n              break;\n            case 'last-modified':\n              res.set(name, util.rfc1123(res.swagger.lastModified));\n              break;\n            case 'content-disposition':\n              res.set(name, 'attachment; filename=\"' + path.basename(res.swagger.location || req.path) + '\"');\n              break;\n            case 'set-cookie':\n              // Generate a random \"swagger\" cookie, or re-use it if it already exists\n              if (req.cookies.swagger === undefined) {\n                res.cookie('swagger', _.uniqueId('random') + _.random(99999999999.9999));\n              }\n              else {\n                res.cookie('swagger', req.cookies.swagger);\n              }\n              break;\n            default:\n              // Generate a sample value from the schema\n              var sample = new JsonSchema(header).sample();\n              if (_.isDate(sample)) {\n                res.set(name, util.rfc1123(sample));\n              }\n              else {\n                res.set(name, _(sample).toString());\n              }\n          }\n          util.debug('    %s: %s', name, res.get(name));\n        }\n      });\n    }\n  }\n\n  next();\n}\n\n/**\n * Tries to make the response body adhere to the Swagger API.\n */\nfunction mockResponseBody(req, res, next) {\n  if (res.swagger) {\n    if (res.swagger.isEmpty) {\n      // There is no response schema, so send an empty response\n      util.debug('%s %s does not have a response schema. Sending an empty response', req.method, req.path);\n      res.send();\n    }\n    else {\n      // Serialize the response body according to the response schema\n      var schema = new JsonSchema(res.swagger.schema);\n      var serialized = schema.serialize(res.swagger.wrap(res.body));\n\n      switch (res.swagger.schema.type) {\n        case 'object':\n        case 'array':\n        case undefined:\n          sendObject(req, res, next, serialized);\n          break;\n\n        case 'file':\n          sendFile(req, res, next, serialized);\n          break;\n\n        default:\n          sendText(req, res, next, serialized);\n      }\n    }\n  }\n  else {\n    next();\n  }\n}\n\n/**\n * Sends the given object (or array) as JSON.\n *\n * @param   {Request}       req\n * @param   {Response}      res\n * @param   {function}      next\n * @param   {object|array}  obj\n */\nfunction sendObject(req, res, next, obj) {\n  setContentType(req, res, ['json', '*/json', '+json']);\n\n  util.debug('Serializing the response as JSON');\n  res.json(obj);\n}\n\n/**\n * Sends the given data as plain-text.\n *\n * @param   {Request}   req\n * @param   {Response}  res\n * @param   {function}  next\n * @param   {*}         data\n */\nfunction sendText(req, res, next, data) {\n  setContentType(req, res,\n    ['text', 'html', 'text/*', 'application/*'],                // allow these types\n    ['json', '*/json', '+json', 'application/octet-stream']);   // don't allow these types\n\n  util.debug('Serializing the response as a string');\n  res.send(_(data).toString());\n}\n\n/**\n * Sends the given file as the response.\n * If the file doesn't exist, then an HTTP 410 (Gone) is thrown\n *\n * @param   {Request}           req\n * @param   {Response}          res\n * @param   {function}          next\n * @param   {object|Buffer}     file\n */\nfunction sendFile(req, res, next, file) {\n  if (file instanceof Buffer) {\n    setContentType(req, res, ['application/octet-stream', '*/*']);\n\n    // `file` is the file's contents\n    util.debug('Sending raw buffer data');\n    res.send(file);\n    return;\n  }\n\n  // `file` is a file info object\n  fs.exists(file.path || '', function(exists) {\n    if (exists) {\n      var isAttachment = _.some(res.swagger.headers, function(header, name) {\n        return name.toLowerCase() === 'content-disposition';\n      });\n\n      if (isAttachment) {\n        // Get the filename from the \"Content-Disposition\" header,\n        // or fallback to the request path\n        var fileName = /filename\\=\\\"(.+)\\\"/.exec(res.get('content-disposition'));\n        fileName = fileName ? fileName[1] : req.path;\n\n        util.debug('Sending \"%s\" as an attachment named \"%s\"', file.path, fileName);\n        res.download(file.path, fileName);\n      }\n      else {\n        util.debug('Sending \"%s\" contents', file.path);\n        res.sendFile(file.path, {lastModified: false});\n      }\n    }\n    else {\n      // Throw an HTTP 410 (Gone)\n      util.debug('Unable to find the file: \"%s\".  Sending an HTTP 410 (Gone)', file.path);\n      next(util.newError(410, '%s no longer exists', file.path || req.path));\n    }\n  });\n}\n\n/**\n * Sets the Content-Type HTTP header to one of the given options.\n * The best option is chosen, based on the MIME types that this operation produces.\n *\n * @param   {Request}   req\n * @param   {Response}  res\n * @param   {string[]}  supported       A list of MIME types that are supported\n * @param   {string[]}  [excluded]      A list of MIME types to exclude from the supported list\n */\nfunction setContentType(req, res, supported, excluded) {\n  // Get the MIME types that this operation produces\n  var produces = req.swagger.operation.produces || req.swagger.api.produces || [];\n\n  if (produces.length === 0) {\n    // No MIME types were specified, so just use the first one\n    util.debug('No \"produces\" MIME types are specified in the Swagger API, so defaulting to %s', supported[0]);\n    res.type(supported[0]);\n  }\n  else {\n    // Find the first MIME type that we support\n    var match = _.find(produces, function(mimeType) {\n      return typeIs.is(mimeType, supported) &&\n        (!excluded || !typeIs.is(mimeType, excluded));\n    });\n\n    if (match) {\n      util.debug('Using %s MIME type, which is allowed by the Swagger API', match);\n      res.type(match);\n    }\n    else {\n      util.warn(\n        'WARNING! %s %s produces the MIME types that are not supported (%s). Using \"%s\" instead',\n        req.method, req.path, produces.join(', '), supported[0]\n      );\n      res.type(supported[0]);\n    }\n  }\n}\n","/home/travis/build/npmtest/node-npmtest-swagger-express-middleware/node_modules/swagger-express-middleware/lib/data-store/memory-data-store.js":"'use strict';\n\nmodule.exports = MemoryDataStore;\n\nvar DataStore = require('./index'),\n    Resource  = require('./resource');\n\n// Inheritance\nMemoryDataStore.prototype = Object.create(DataStore.prototype);\nMemoryDataStore.prototype.constructor = MemoryDataStore;\n\n/**\n * An in-memory data store for REST resources.\n * @constructor\n * @extends DataStore\n */\nfunction MemoryDataStore() {\n  DataStore.call(this);\n\n  /**\n   * This implementation of DataStore uses an in-memory array.\n   * @type {Resource[]}\n   * @private\n   */\n  this.__resourceStore = [];\n}\n\n/**\n * Overrides {@link DataStore#__openDataStore} to return data from an in-memory array.\n * @protected\n */\nMemoryDataStore.prototype.__openDataStore = function(collection, callback) {\n  setImmediate(callback, null, this.__resourceStore);\n};\n\n/**\n * Overrides {@link DataStore#__saveDataStore} to store data in an in-memory array.\n * @protected\n */\nMemoryDataStore.prototype.__saveDataStore = function(collection, resources, callback) {\n  try {\n    this.__resourceStore = Resource.parse(resources);\n    setImmediate(callback);\n  }\n  catch (e) {\n    callback(e);\n  }\n};\n","/home/travis/build/npmtest/node-npmtest-swagger-express-middleware/node_modules/swagger-express-middleware/lib/mock/semantic-request.js":"'use strict';\n\nmodule.exports = SemanticRequest;\n\nvar util             = require('../helpers/util'),\n    SemanticResponse = require('./semantic-response');\n\n/**\n * Describes the semantics of a Swagger request.\n *\n * @param {Request} req\n * @constructor\n */\nfunction SemanticRequest(req) {\n  /**\n   * Indicates whether this is a \"resource path\" or a \"collection path\".\n   * Resource path operate on a single REST resource, whereas collection requests operate on\n   * a collection of resources.\n   * @type {boolean}\n   */\n  this.isCollection = isCollectionRequest(req);\n}\n\n/**\n * Determines whether the given path is a \"resource path\" or a \"collection path\".\n * Resource paths operate on a single REST resource, whereas collection paths operate on\n * a collection of resources.\n *\n * NOTE: This algorithm is subject to change. Over time, it should get smarter and better at determining request types.\n *\n * @param   {Request} req\n * @returns {boolean}\n */\nfunction isCollectionRequest(req) {\n  var isCollection = responseIsCollection(req);\n\n  if (isCollection === undefined) {\n    isCollection = !lastPathSegmentIsAParameter(req);\n  }\n\n  return isCollection;\n}\n\n/**\n * Examines the GET or HEAD operation for the path and determines whether it is a collection response.\n *\n * @param   {Request} req\n *\n * @returns {boolean|undefined}\n * True if the response schema is a collection.  False if it's not a collection.  Undefined if there is not response schema.\n */\nfunction responseIsCollection(req) {\n  var getter = req.swagger.path.get || req.swagger.path.head;\n  if (getter) {\n    var responses = util.getResponsesBetween(getter, 200, 299);\n    if (responses.length > 0) {\n      var response = new SemanticResponse(responses[0].api, req.swagger.path);\n      if (!response.isEmpty) {\n        return response.isCollection;\n      }\n    }\n  }\n}\n\n/**\n * Determines whether the last path segment is a Swagger parameter.\n *\n * For example, the following paths are all considered to be resource requests,\n * because their final path segment contains a parameter:\n *\n * - /users/{username}\n * - /products/{productId}/reviews/review-{reviewId}\n * - /{country}/{state}/{city}\n *\n * Conversely, the following paths are all considered to be collection requests,\n * because their final path segment is NOT a parameter:\n *\n * - /users\n * - /products/{productId}/reviews\n * - /{country}/{state}/{city}/neighborhoods/streets\n *\n * @param req\n * @returns {boolean}\n */\nfunction lastPathSegmentIsAParameter(req) {\n  var lastSlash = req.swagger.pathName.lastIndexOf('/');\n  var lastParam = req.swagger.pathName.lastIndexOf('{');\n  return (lastParam > lastSlash);\n}\n","/home/travis/build/npmtest/node-npmtest-swagger-express-middleware/node_modules/swagger-express-middleware/lib/mock/semantic-response.js":"'use strict';\n\nmodule.exports = SemanticResponse;\n\nvar _    = require('lodash'),\n    util = require('../helpers/util');\n\n/**\n * Describes the semantics of a Swagger response.\n *\n * @param   {object}    response    The Response object, from the Swagger API\n * @param   {object}    path        The Path object that contains the response. Used for semantic analysis.\n * @constructor\n */\nfunction SemanticResponse(response, path) {\n  /**\n   * The JSON schema of the response\n   * @type {object|null}\n   */\n  this.schema = response.schema || null;\n\n  /**\n   * The response headers, from the Swagger API\n   * @type {object|null}\n   */\n  this.headers = response.headers || null;\n\n  /**\n   * If true, then an empty response should be sent.\n   * @type {boolean}\n   */\n  this.isEmpty = !response.schema;\n\n  /**\n   * Indicates whether the response should be a single resource, or a collection.\n   * @type {boolean}\n   */\n  this.isCollection = false;\n\n  /**\n   * Indicates whether the response schema is a wrapper around the actual resource data.\n   * It's common for RESTful APIs to include a response wrapper with additional metadata,\n   * and one of the properties of the wrapper is the actual resource data.\n   * @type {boolean}\n   */\n  this.isWrapped = false;\n\n  /**\n   * If the response is wrapped, then this is the name of the wrapper property that\n   * contains the actual resource data.\n   * @type {string}\n   */\n  this.wrapperProperty = '';\n\n  /**\n   * The date/time that the response data was last modified.\n   * This is used to set the Last-Modified HTTP header (if defined in the Swagger API)\n   *\n   * Each mock implementation sets this to the appropriate value.\n   *\n   * @type {Date}\n   */\n  this.lastModified = null;\n\n  /**\n   * The location (URL) of the REST resource.\n   * This is used to set the Location HTTP header (if defined in the Swagger API)\n   *\n   * Some mocks implementations set this value.  If left blank, then the Location header\n   * will be set to the current path.\n   *\n   * @type {string}\n   */\n  this.location = '';\n\n  if (!this.isEmpty) {\n    this.setWrapperInfo(response, path);\n  }\n}\n\n/**\n * Wraps the given data in the appropriate wrapper object, if applicable.\n *\n * @param   {*}     data    The data to (possibly) be wrapped\n * @returns {*}             The (possibly) wrapped data\n */\nSemanticResponse.prototype.wrap = function(data) {\n  if (this.isWrapped) {\n    var wrapper = {};\n    wrapper[this.wrapperProperty] = data;\n    return wrapper;\n  }\n  else {\n    return data;\n  }\n};\n\n/**\n * Determines whether the response schema is a wrapper object, and sets the corresponding properties.\n *\n * @param   {object}    response    The Response object, from the Swagger API\n * @param   {object}    path        The Path object that contains the response. Used for semantic analysis.\n */\nSemanticResponse.prototype.setWrapperInfo = function(response, path) {\n  var self = this;\n\n  if (response.schema.type === 'array') {\n    // Assume that it's a collection.  It's also NOT wrapped\n    self.isCollection = true;\n  }\n  else if (response.schema.type === 'object' || response.schema.type === undefined) {\n    var resourceSchemas = getResourceSchemas(path);\n\n    // If the response schema matches one of the resource schemas, then it's NOT wrapped\n    if (!schemasMatch(resourceSchemas, response.schema)) {\n      // The response schema doesn't match any of the resource schemas,\n      // so check each of its properties to see if any of them match\n      _.some(response.schema.properties, function(propSchema, propName) {\n        var isArray = false;\n        if (propSchema.type === 'array') {\n          isArray = true;\n          propSchema = propSchema.items;\n        }\n\n        if (propSchema.type === 'object' || propSchema.type === undefined) {\n          if (schemasMatch(resourceSchemas, propSchema)) {\n            // The response schema is a wrapper object,\n            // and this property contains the actual resource data\n            self.isWrapped = true;\n            self.wrapperProperty = propName;\n            self.isCollection = isArray;\n            return true;\n          }\n        }\n      });\n    }\n  }\n};\n\n/**\n * Returns the JSON schemas for the given path's PUT, POST, and PATCH operations.\n * Usually these operations are not wrapped, so we can assume that they are the actual resource schema.\n *\n * @param   {object}    path    A Path object, from the Swagger API.\n * @returns {object[]}          An array of JSON schema objects\n */\nfunction getResourceSchemas(path) {\n  var schemas = [];\n\n  ['post', 'put', 'patch'].forEach(function(operation) {\n    if (path[operation]) {\n      schemas.push(util.getRequestSchema(path, path[operation]));\n    }\n  });\n\n  return schemas;\n}\n\n/**\n * Determines whether the given JSON schema matches any of the given JSON schemas.\n *\n * @param   {object[]}  schemasToMatch  An array of JSON schema objects\n * @param   {object}    schemaToTest    The JSON schema object to test against the other schemas\n * @returns {boolean}                   Returns true if the schema matches any of the other schemas\n */\nfunction schemasMatch(schemasToMatch, schemaToTest) {\n  var propertiesToTest = 0;\n  if (schemaToTest.properties) {\n    propertiesToTest = Object.keys(schemaToTest.properties).length;\n  }\n\n  return schemasToMatch.some(function(schemaToMatch) {\n    var propertiesToMatch = 0;\n    if (schemaToMatch.properties) {\n      propertiesToMatch = Object.keys(schemaToMatch.properties).length;\n    }\n\n    // Make sure both schemas are the same type and have the same number of properties\n    if (schemaToTest.type === schemaToMatch.type && propertiesToTest === propertiesToMatch) {\n      // Compare each property in both schemas\n      return _.every(schemaToMatch.properties, function(propertyToMatch, propName) {\n        var propertyToTest = schemaToTest.properties[propName];\n        return propertyToTest && propertyToMatch.type === propertyToTest.type;\n      });\n    }\n  });\n}\n","/home/travis/build/npmtest/node-npmtest-swagger-express-middleware/node_modules/swagger-express-middleware/lib/mock/edit-resource.js":"'use strict';\n\nmodule.exports = {\n  POST: mergeResource,\n  PATCH: mergeResource,\n  PUT: overwriteResource,\n  DELETE: deleteResource\n};\n\nvar _        = require('lodash'),\n    Resource = require('../data-store/resource'),\n    util     = require('../helpers/util');\n\n/**\n * Creates or updates the REST resource at the URL.\n *\n * If the resource already exists, then the new data is merged with the existing data.\n * To completely overwrite the existing data, use PUT instead of POST or PATCH.\n *\n * @param   {Request}   req\n * @param   {Response}  res\n * @param   {function}  next\n * @param   {DataStore} dataStore\n */\nfunction mergeResource(req, res, next, dataStore) {\n  var resource = createResource(req);\n\n  // Save/Update the resource\n  util.debug('Saving data at %s', resource.toString());\n  dataStore.save(resource, sendResponse(req, res, next, dataStore));\n}\n\n/**\n * Creates or overwrites the REST resource at the URL.\n *\n * If the resource already exists, it is overwritten.\n * To merge with the existing data, use POST or PATCH instead of PUT.\n *\n * @param   {Request}   req\n * @param   {Response}  res\n * @param   {function}  next\n * @param   {DataStore} dataStore\n */\nfunction overwriteResource(req, res, next, dataStore) {\n  var resource = createResource(req);\n\n  // Delete the existing resource, if any\n  dataStore.delete(resource, function(err) {\n    if (err) {\n      next(err);\n    }\n    else {\n      // Save the new resource\n      util.debug('Saving data at %s', resource.toString());\n      dataStore.save(resource, sendResponse(req, res, next, dataStore));\n    }\n  });\n}\n\n/**\n * Deletes the REST resource at the URL.\n * If the resource does not exist, then nothing happens.  No error is thrown.\n *\n * @param   {Request}   req\n * @param   {Response}  res\n * @param   {function}  next\n * @param   {DataStore} dataStore\n */\nfunction deleteResource(req, res, next, dataStore) { // jshint ignore:line\n  var resource = createResource(req);\n\n  // Delete the resource\n  dataStore.delete(resource, function(err, deletedResource) {\n    // Respond with the deleted resource, if possible; otherwise, use the empty resource we just created.\n    sendResponse(req, res, next, dataStore)(err, deletedResource || resource);\n  });\n}\n\n/**\n * Creates a {@link Resource} objects from the request's data.\n *\n * @param   {Request}   req\n * @returns {Resource}\n */\nfunction createResource(req) {\n  var resource = new Resource(req.path);\n\n  if (!_.isEmpty(req.files)) {\n    // Save file data too\n    resource.data = _.extend({}, req.body, req.files);\n  }\n  else {\n    resource.data = req.body;\n  }\n\n  return resource;\n}\n\n/**\n * Returns a function that sends the correct response for the operation.\n *\n * @param   {Request}   req\n * @param   {Response}  res\n * @param   {function}  next\n * @param   {DataStore} dataStore\n */\nfunction sendResponse(req, res, next, dataStore) {\n  return function(err, resource) {\n    if (!err) {\n      util.debug('%s successfully created/edited/deleted', resource.toString());\n      res.swagger.lastModified = resource.modifiedOn;\n    }\n\n    // Set the response body (unless it's already been set by other middleware)\n    if (err || res.body) {\n      next(err);\n    }\n    else if (res.swagger.isCollection) {\n      // Response body is the entire collection\n      dataStore.getCollection(resource.collection, function(err, collection) {\n        res.body = _.pluck(collection, 'data');\n        next(err);\n      });\n    }\n    else {\n      // Response body is the resource that was created/update/deleted\n      res.body = resource.data;\n      next();\n    }\n  };\n}\n\n","/home/travis/build/npmtest/node-npmtest-swagger-express-middleware/node_modules/swagger-express-middleware/lib/mock/query-resource.js":"'use strict';\n\nmodule.exports = {\n  GET: queryResource,\n  HEAD: queryResource,\n  OPTIONS: queryResource\n};\n\nvar util     = require('../helpers/util'),\n    Resource = require('../data-store/resource');\n\n/**\n * Returns the REST resource at the URL.\n * If there's no resource that matches the URL, then a 404 error is returned.\n *\n * @param   {Request}   req\n * @param   {Response}  res\n * @param   {function}  next\n * @param   {DataStore} dataStore\n */\nfunction queryResource(req, res, next, dataStore) {\n  var resource = new Resource(req.path);\n\n  dataStore.get(resource, function(err, result) {\n    if (err) {\n      next(err);\n    }\n    else if (!result) {\n      var defaultValue = getDefaultValue(res);\n\n      if (defaultValue === undefined) {\n        util.debug('ERROR! 404 - %s %s does not exist', req.method, req.path);\n        err = util.newError(404, '%s Not Found', resource.toString());\n        next(err);\n      }\n      else {\n        // There' a default value, so use it instead of sending a 404\n        util.debug(\n          '%s %s does not exist, but the response schema defines a fallback value.  So, using the fallback value',\n          req.method, req.path\n        );\n        res.swagger.lastModified = new Date();\n        res.body = defaultValue;\n        next();\n      }\n    }\n    else {\n      res.swagger.lastModified = result.modifiedOn;\n\n      // Set the response body (unless it's already been set by other middleware)\n      res.body = res.body || result.data;\n      next();\n    }\n  });\n}\n\n/**\n * Returns the default/example value for this request.\n */\nfunction getDefaultValue(res) {\n  if (res.body) {\n    return res.body;\n  }\n  else if (res.swagger.schema) {\n    return res.swagger.schema.default || res.swagger.schema.example;\n  }\n}\n","/home/travis/build/npmtest/node-npmtest-swagger-express-middleware/node_modules/swagger-express-middleware/lib/mock/edit-collection.js":"'use strict';\n\nmodule.exports = {\n  POST: mergeCollection,\n  PATCH: mergeCollection,\n  PUT: overwriteCollection\n};\n\nvar _          = require('lodash'),\n    path       = require('path'),\n    util       = require('../helpers/util'),\n    Resource   = require('../data-store/resource'),\n    JsonSchema = require('../helpers/json-schema');\n\n/**\n * Adds one or more REST resources to the collection, or updates them if they already exist.\n * A unique URL is generated for each new resource, based on the schema definition in the Swagger API,\n * and this URL is used to determine whether a given resource is being created or updated.\n *\n * For example, if you POST the data {id: 123, name: 'John Doe'} to /api/users,\n * then the \"id\" property will be used to construct the new REST URL: /api/users/123\n *\n * Similarly, if you POST the data {name: 'John Doe', age: 42} to /api/users,\n * then the \"name\" property will be used to construct the new URL: /api/users/John%20Doe\n *\n * If the data doesn't contain any properties that seem like unique IDs, then a unique ID is generated,\n * which means new resources will always be created, and never updated.\n *\n * @param   {Request}   req\n * @param   {Response}  res\n * @param   {function}  next\n * @param   {DataStore} dataStore\n */\nfunction mergeCollection(req, res, next, dataStore) {\n  var collection = req.path;\n  var resources = createResources(req);\n\n  // Set the \"Location\" HTTP header.\n  // If the operation allows saving multiple resources, then use the collection path.\n  // If the operation only saves a single resource, then use the resource's path.\n  res.swagger.location = _.isArray(req.body) ? collection : resources[0].toString();\n\n  // Save/Update the resources\n  util.debug('Saving data at %s', res.swagger.location);\n  dataStore.save(resources, sendResponse(req, res, next, dataStore));\n}\n\n/**\n * Adds one or more REST resources to the collection, or overwrites them if they already exist.\n * A unique URL is generated for each new resource, based on the schema definition in the Swagger API,\n * and this URL is used to determine whether a given resource is being created or overwritten.\n *\n * For example, if you POST the data {id: 123, name: 'John Doe'} to /api/users,\n * then the \"id\" property will be used to construct the new REST URL: /api/users/123\n *\n * Similarly, if you POST the data {name: 'John Doe', age: 42} to /api/users,\n * then the \"name\" property will be used to construct the new URL: /api/users/John%20Doe\n *\n * If the data doesn't contain any properties that seem like unique IDs, then a unique ID is generated,\n * which means new resources will always be created, and never overwritten.\n *\n * @param   {Request}   req\n * @param   {Response}  res\n * @param   {function}  next\n * @param   {DataStore} dataStore\n */\nfunction overwriteCollection(req, res, next, dataStore) {\n  var collection = req.path;\n  var resources = createResources(req);\n\n  // Set the \"Location\" HTTP header.\n  // If the operation allows saving multiple resources, then use the collection path.\n  // If the operation only saves a single resource, then use the resource's path.\n  res.swagger.location = _.isArray(req.body) ? collection : resources[0].toString();\n\n  // Delete the existing resources\n  dataStore.delete(resources, function(err) {\n    if (err) {\n      next(err);\n    }\n    else {\n      // Save the new resources\n      util.debug('Saving data at %s', res.swagger.location);\n      dataStore.save(resources, sendResponse(req, res, next, dataStore));\n    }\n  });\n}\n\n/**\n * Creates {@link Resource} objects for each resource in the request\n *\n * @param   {Request}   req\n * @returns {Resource[]}\n */\nfunction createResources(req) {\n  var resources = [],\n      body      = req.body,\n      schema    = util.getRequestSchema(req.swagger.path, req.swagger.operation);\n\n  if (!_.isArray(body)) {\n    if (!_.isEmpty(req.files)) {\n      // Save file data too\n      body = _.extend({}, req.body, req.files);\n    }\n\n    // Normalize to an array\n    body = [body];\n  }\n\n  // Create a REST resource for each item in the array\n  for (var i = 0; i < body.length; i++) {\n    var data = body[i];\n\n    // Determine the resource's \"Name\" property\n    var propInfo = getResourceName(data, schema);\n\n    if (propInfo.name) {\n      // Update the data, so the new name is saved with the resource data\n      data = data || {};\n      if (data[propInfo.name] === undefined) {\n        data[propInfo.name] = propInfo.value;\n        body[i] = data;\n      }\n    }\n\n    // Create a resource name that is a safe URL string (2000 character max)\n    var resourceName = new JsonSchema(propInfo.schema).serialize(propInfo.value);\n    resourceName = _(resourceName).toString().substring(0, 2000);\n    resourceName = encodeURIComponent(resourceName);\n\n    // Create a REST resource\n    var resource = new Resource(req.path, resourceName, data);\n    resources.push(resource);\n  }\n\n  return resources;\n}\n\n/**\n * Returns the property that is the REST resource's \"unique\" name.\n *\n * @param   {*}         data        The parsed resource data.\n * @param   {object}    schema      The JSON schema for the data.\n * @returns {PropertyInfo}          The resource's name.\n */\nfunction getResourceName(data, schema) {\n  // Try to find the \"name\" property using several different methods\n  var propInfo =\n        getResourceNameByValue(data, schema) ||\n        getResourceNameByName(data, schema) ||\n        getResourceNameByRequired(data, schema) ||\n        getResourceNameByFile(data, schema);\n\n  if (propInfo) {\n    util.debug('The \"%s\" property (%j) appears to be the REST resource\\'s name', propInfo.name, propInfo.value);\n\n    if (propInfo.value === undefined) {\n      propInfo.value = new JsonSchema(propInfo.schema).sample();\n      util.debug('Generated new value (%j) for the \"%s\" property', propInfo.value, propInfo.name);\n    }\n\n    return propInfo;\n  }\n  else {\n    util.debug('Unable to determine the unique name for the REST resource. Generating a unique value instead');\n    return {\n      name: '',\n      schema: {type: 'string'},\n      value: _.uniqueId()\n    };\n  }\n}\n\n/**\n * If the REST resource is a simple value (number, string, date, etc.),\n * then the value is returned as the resource's name.\n *\n * @param   {*}         data        The parsed resource data.\n * @param   {object}    schema      The JSON schema for the data.\n * @returns {PropertyInfo|undefined}\n */\nfunction getResourceNameByValue(data, schema) {\n  if (schema.type !== 'object' && schema.type !== undefined) {\n    // The resource is a simple value, so just return the raw data as the \"name\"\n    return {\n      name: '',\n      schema: schema,\n      value: data\n    };\n  }\n}\n\n/**\n * Tries to find the REST resource's name by searching for commonly-used property names like \"id\", \"key\", etc.\n *\n * @param   {*}         data        The parsed resource data.\n * @param   {object}    schema      The JSON schema for the data.\n * @returns {PropertyInfo|undefined}\n */\nfunction getResourceNameByName(data, schema) {\n  /** @name PropertyInfo */\n  var propInfo = {\n    name: '',\n    schema: {\n      type: ''\n    },\n    value: undefined\n  };\n\n  // Get a list of all existing and possible properties of the resource\n  var propNames = _.union(_.keys(schema.properties), _.keys(data));\n\n  // Lowercase property names, for comparison\n  var lowercasePropNames = propNames.map(function(propName) { return propName.toLowerCase(); });\n\n  // These properties are assumed to be unique IDs.\n  // If we find any of them in the schema, then use it as the REST resource's name.\n  var nameProperties = ['id', 'key', 'slug', 'code', 'number', 'num', 'nbr', 'username', 'name'];\n  var foundMatch = nameProperties.some(function(lowercasePropName) {\n    var index = lowercasePropNames.indexOf(lowercasePropName);\n    if (index >= 0) {\n      // We found a property that appears to be the resource's name. Get its info.\n      propInfo.name = propNames[index];\n      propInfo.value = data ? data[propInfo.name] : undefined;\n\n      if (schema.properties[propInfo.name]) {\n        propInfo.schema = schema.properties[propInfo.name];\n      }\n      else if (_.isDate(data[propInfo.name])) {\n        propInfo.schema = {\n          type: 'string',\n          format: 'date-time'\n        };\n      }\n      else {\n        propInfo.schema.type = typeof(data[propInfo.name]);\n      }\n\n      // If the property is valid, then we're done\n      return isValidResourceName(propInfo);\n    }\n  });\n\n  return foundMatch ? propInfo : undefined;\n}\n\n/**\n * Tries to find the REST resource's name using the required properties in the JSON schema.\n * We're assuming that if the resource has a name, it'll be a required property.\n *\n * @param   {*}         data        The parsed resource data.\n * @param   {object}    schema      The JSON schema for the data.\n * @returns {PropertyInfo|undefined}\n */\nfunction getResourceNameByRequired(data, schema) {\n  var propInfo = {\n    name: '',\n    schema: {\n      type: ''\n    },\n    value: undefined\n  };\n\n  var foundMatch = _.some(schema.required, function(propName) {\n    propInfo.name = propName;\n    propInfo.schema = schema.properties[propName];\n    propInfo.value = data[propName];\n\n    // If the property is valid, then we're done\n    return isValidResourceName(propInfo);\n  });\n\n  return foundMatch ? propInfo : undefined;\n}\n\n/**\n * If the REST resource contains a file (e.g. multipart/form-data or application/x-www-form-urlencoded),\n * then we'll use the file name as the resource name.\n *\n * @param   {*}         data        The parsed resource data.\n * @param   {object}    schema      The JSON schema for the data.\n * @returns {PropertyInfo|undefined}\n */\nfunction getResourceNameByFile(data, schema) {\n  // Find all file parameters\n  var files = _.where(schema.properties, {type: 'file'});\n\n  // If there is exactly ONE file parameter, then we'll use its file name\n  if (files.length === 1) {\n    var file = data[files[0].name];\n    if (file && (file.originalname || file.path)) {\n      return {\n        name: file.fieldname,\n        schema: {\n          type: 'string'\n        },\n\n        // Use the original file name, if provided. Otherwise, fallback to the server-side file name\n        value: file.originalname || path.basename(file.path)\n      };\n    }\n  }\n}\n\n/**\n * Determines whether the given property is a valid REST resource name.\n * Only simple types (strings, numbers, booleans) are used as keys.\n * Complex types (arrays, objects, files) are ignored.\n *\n * @param   {PropertyInfo}    propInfo\n * @returns {boolean}\n */\nfunction isValidResourceName(propInfo) {\n  var validTypes = ['string', 'number', 'integer', 'boolean'];\n  return validTypes.indexOf(propInfo.schema.type.toLocaleLowerCase()) >= 0;\n}\n\n/**\n * Returns a function that sends the correct response for the operation.\n *\n * @param   {Request}       req\n * @param   {Response}      res\n * @param   {function}      next\n * @param   {DataStore}     dataStore\n */\nfunction sendResponse(req, res, next, dataStore) {\n  return function(err, resources) {\n    if (!err) {\n      util.debug('%s successfully updated', res.swagger.location);\n\n      if (resources.length > 0) {\n        // Determine the max \"modifiedOn\" date of the resources\n        res.swagger.lastModified = _.max(resources, 'modifiedOn').modifiedOn;\n      }\n      else {\n        // There is no data, so use the current date/time as the \"last-modified\" header\n        res.swagger.lastModified = new Date();\n      }\n\n      // Extract the \"data\" of each Resource\n      resources = _.pluck(resources, 'data');\n    }\n\n    // Set the response body (unless it's already been set by other middleware)\n    if (err || res.body) {\n      next(err);\n    }\n    else if (!res.swagger.isCollection) {\n      // Response body is a single value, so only return the first item that was edited\n      res.body = _.first(resources);\n      next();\n    }\n    else {\n      // Response body is the entire collection (new, edited, and old)\n      dataStore.getCollection(req.path, function(err, collection) {\n        res.body = _.pluck(collection, 'data');\n        next(err);\n      });\n    }\n  };\n}\n\n","/home/travis/build/npmtest/node-npmtest-swagger-express-middleware/node_modules/swagger-express-middleware/lib/mock/query-collection.js":"'use strict';\n\nmodule.exports = {\n  GET: queryCollection,\n  HEAD: queryCollection,\n  OPTIONS: queryCollection,\n  DELETE: deleteCollection\n};\n\nvar _    = require('lodash'),\n    util = require('../helpers/util');\n\n/**\n * Returns an array of all resources in the collection.\n * If there are no resources, then an empty array is returned.  No 404 error is thrown.\n *\n * If the Swagger API includes \"query\" parameters, they can be used to filter the results.\n * Deep property names are allowed (e.g. \"?address.city=New+York\").\n * Query string params that are not defined in the Swagger API are ignored.\n *\n * @param   {Request}   req\n * @param   {Response}  res\n * @param   {function}  next\n * @param   {DataStore} dataStore\n */\nfunction queryCollection(req, res, next, dataStore) {\n  dataStore.getCollection(req.path, function(err, resources) {\n    if (!err) {\n      resources = filter(resources, req);\n\n      if (resources.length > 0) {\n        // Determine the max \"modifiedOn\" date of the remaining items\n        res.swagger.lastModified = _.max(resources, 'modifiedOn').modifiedOn;\n\n        // Extract the \"data\" of each Resource\n        resources = _.pluck(resources, 'data');\n      }\n      else {\n        // There is no data, so use the current date/time as the \"last-modified\" header\n        res.swagger.lastModified = new Date();\n      }\n\n      // Set the response body (unless it's already been set by other middleware)\n      res.body = res.body || resources;\n    }\n\n    next(err);\n  });\n}\n\n/**\n * Deletes all resources in the collection.\n * If there are no resources, then nothing happens.  No error is thrown.\n *\n * If the Swagger API includes \"query\" parameters, they can be used to filter what gets deleted.\n * Deep property names are allowed (e.g. \"?address.city=New+York\").\n * Query string params that are not defined in the Swagger API are ignored.\n *\n * @param   {Request}   req\n * @param   {Response}  res\n * @param   {function}  next\n * @param   {DataStore} dataStore\n */\nfunction deleteCollection(req, res, next, dataStore) {\n  dataStore.getCollection(req.path, function(err, resources) {\n    if (err) {\n      next(err);\n    }\n    else {\n      // Determine which resources to delete, based on query params\n      var resourcesToDelete = filter(resources, req);\n\n      if (resourcesToDelete.length === 0) {\n        sendResponse(null, []);\n      }\n      else if (resourcesToDelete.length === resources.length) {\n        // Delete the whole collection\n        dataStore.deleteCollection(req.path, sendResponse);\n      }\n      else {\n        // Only delete the matching resources\n        dataStore.delete(resourcesToDelete, sendResponse);\n      }\n    }\n  });\n\n  // Responds with the deleted resources\n  function sendResponse(err, resources) {\n    // Extract the \"data\" of each Resource\n    resources = _.pluck(resources, 'data');\n\n    // Use the current date/time as the \"last-modified\" header\n    res.swagger.lastModified = new Date();\n\n    // Set the response body (unless it's already been set by other middleware)\n    if (err || res.body) {\n      next(err);\n    }\n    else if (!res.swagger.isCollection) {\n      // Response body is a single value, so only return the first item in the collection\n      res.body = _.first(resources);\n      next();\n    }\n    else {\n      // Response body is the resource that was created/update/deleted\n      res.body = resources;\n      next();\n    }\n  }\n}\n\n/**\n * Filters the given {@link Resource} array, using the \"query\" params defined in the Swagger API.\n *\n * @param   {Resource[]}    resources\n * @param   {Request}       req\n * @returns {Resource[]}\n */\nfunction filter(resources, req) {\n  util.debug('There are %d resources in %s', resources.length, req.path);\n\n  if (resources.length > 0) {\n    // If there are query params, then filter the collection by them\n    var queryParams = _.where(req.swagger.params, {in: 'query'});\n    if (queryParams.length > 0) {\n      // Build the filter object\n      var filterCriteria = {data: {}};\n      queryParams.forEach(function(param) {\n        if (req.query[param.name] !== undefined) {\n          setDeepProperty(filterCriteria.data, param.name, req.query[param.name]);\n        }\n      });\n\n      if (!_.isEmpty(filterCriteria.data)) {\n        // Filter the collection\n        util.debug('Filtering resources by %j', filterCriteria.data);\n        resources = _.where(resources, filterCriteria);\n        util.debug('%d resources matched the filter criteria', resources.length);\n      }\n    }\n  }\n\n  return resources;\n}\n\n/**\n * Sets a deep property of the given object.\n *\n * @param   {object}    obj         The object whose property is to be set.\n * @param   {string}    propName    The deep property name (e.g. \"Vet.Address.State\")\n * @param   {*}         propValue   The value to set\n */\nfunction setDeepProperty(obj, propName, propValue) {\n  propName = propName.split('.');\n  for (var i = 0; i < propName.length - 1; i++) {\n    obj = obj[propName[i]] = obj[propName[i]] || {};\n  }\n  obj[propName[propName.length - 1]] = propValue;\n}\n","/home/travis/build/npmtest/node-npmtest-swagger-express-middleware/node_modules/swagger-express-middleware/lib/data-store/file-data-store.js":"'use strict';\n\nmodule.exports = FileDataStore;\n\nvar DataStore = require('./index'),\n    Resource  = require('./resource'),\n    fs        = require('fs'),\n    path      = require('path'),\n    mkdirp    = require('mkdirp');\n\n// Inheritance\nFileDataStore.prototype = Object.create(DataStore.prototype);\nFileDataStore.prototype.constructor = FileDataStore;\n\n/**\n * A JSON file data store for REST resources. Each collection is stored as a separate file.\n *\n * @param   {string}    baseDir     The base directory where the JSON files will be saved.\n * @constructor\n * @extends DataStore\n */\nfunction FileDataStore(baseDir) {\n  DataStore.call(this);\n  this.__baseDir = baseDir || process.cwd();\n}\n\n/**\n * Overrides {@link DataStore#__openDataStore} to return data from a JSON file.\n * @protected\n */\nFileDataStore.prototype.__openDataStore = function(collection, callback) {\n  fs.readFile(getFilePath(this.__baseDir, collection), {encoding: 'utf8'}, function(err, data) {\n    if (err) {\n      if (err.code === 'ENOENT') {\n        // The file doesn't exist yet, so just return an empty array\n        callback(null, []);\n      }\n      else {\n        callback(err);\n      }\n    }\n    else {\n      var resources;\n      try {\n        // Parse the JSON data into an array of Resource objects\n        resources = Resource.parse(data);\n      }\n      catch (e) {\n        callback(e);\n        return;\n      }\n\n      // Call the callback outside of the try..catch block,\n      // so we don't catch any errors that happen in third-party code\n      callback(null, resources);\n    }\n  });\n};\n\n/**\n * Overrides {@link DataStore#__saveDataStore} to store data in a a JSON file.\n * @protected\n */\nFileDataStore.prototype.__saveDataStore = function(collection, resources, callback) {\n  var self = this;\n\n  // Create the directory path\n  mkdirp(getDirectory(this.__baseDir, collection), function(err) {\n    if (err) {\n      callback(err);\n    }\n    else {\n      // Write the JSON data to the file\n      fs.writeFile(getFilePath(self.__baseDir, collection), JSON.stringify(resources, null, 2), callback);\n    }\n  });\n};\n\n/**\n * Returns the directory where the given collection's JSON file is stored.\n *\n * @param   {string}    baseDir         (e.g. \"/some/base/path\")\n * @param   {string}    collection      (e.g. \"/users/jdoe/orders\")\n * @returns {string}                    (e.g. \"/some/base/path/users/jdoe\")\n */\nfunction getDirectory(baseDir, collection) {\n  var dir = collection.substring(0, collection.lastIndexOf('/'));\n  dir = dir.toLowerCase();\n  return path.normalize(path.join(baseDir, dir));\n}\n\n/**\n * Returns the full path of the JSON file for the given collection.\n *\n * @param   {string}    baseDir         (e.g. \"/some/base/path\")\n * @param   {string}    collection      (e.g. \"/users/jdoe/orders\")\n * @returns {string}                    (e.g. \"/some/base/path/users/jdoe/orders.json\")\n */\nfunction getFilePath(baseDir, collection) {\n  var directory = getDirectory(baseDir, collection);\n  var fileName = collection.substring(collection.lastIndexOf('/') + 1) + '.json';\n  fileName = fileName.toLowerCase();\n  return path.join(directory, fileName);\n}\n","/home/travis/build/npmtest/node-npmtest-swagger-express-middleware/node_modules/swagger-express-middleware/samples/sample1.js":"'use strict';\n/**************************************************************************************************\n * This sample demonstrates the most simplistic usage of Swagger-Express-Middleware.\n * It simply creates a new Express Application and adds all of the Swagger middleware\n * without changing any options, and without adding any custom middleware.\n **************************************************************************************************/\n\n// Set the DEBUG environment variable to enable debug output\nprocess.env.DEBUG = 'swagger:middleware';\n\nvar express = require('express');\nvar middleware = require('swagger-express-middleware');\n\nvar app = express();\n\nmiddleware('PetStore.yaml', app, function(err, middleware) {\n  // Add all the Swagger Express Middleware, or just the ones you need.\n  // NOTE: Some of these accept optional options (omitted here for brevity)\n  app.use(\n    middleware.metadata(),\n    middleware.CORS(),\n    middleware.files(),\n    middleware.parseRequest(),\n    middleware.validateRequest(),\n    middleware.mock()\n  );\n\n  app.listen(8000, function() {\n    console.log('The Swagger Pet Store is now running at http://localhost:8000');\n  });\n});\n","/home/travis/build/npmtest/node-npmtest-swagger-express-middleware/node_modules/swagger-express-middleware/samples/node_modules/swagger-express-middleware/index.js":"module.exports = require('../../../');\n","/home/travis/build/npmtest/node-npmtest-swagger-express-middleware/node_modules/swagger-express-middleware/samples/sample2.js":"'use strict';\n/**************************************************************************************************\n * This sample demonstrates a few more advanced features of Swagger-Express-Middleware,\n * such as setting a few options, initializing the mock data store, and adding custom middleware logic.\n **************************************************************************************************/\n\n// Set the DEBUG environment variable to enable debug output of Swagger Middleware AND Swagger Parser\nprocess.env.DEBUG = 'swagger:*';\n\nvar util            = require('util'),\n    path            = require('path'),\n    express         = require('express'),\n    swagger         = require('swagger-express-middleware'),\n    Middleware      = swagger.Middleware,\n    MemoryDataStore = swagger.MemoryDataStore,\n    Resource        = swagger.Resource;\n\nvar app = express();\nvar middleware = new Middleware(app);\n\nmiddleware.init('PetStore.yaml', function(err) {\n  // Create a custom data store with some initial mock data\n  var myDB = new MemoryDataStore();\n  myDB.save(\n    new Resource('/pets/Lassie', {name: 'Lassie', type: 'dog', tags: ['brown', 'white']}),\n    new Resource('/pets/Clifford', {name: 'Clifford', type: 'dog', tags: ['red', 'big']}),\n    new Resource('/pets/Garfield', {name: 'Garfield', type: 'cat', tags: ['orange']}),\n    new Resource('/pets/Snoopy', {name: 'Snoopy', type: 'dog', tags: ['black', 'white']}),\n    new Resource('/pets/Hello%20Kitty', {name: 'Hello Kitty', type: 'cat', tags: ['white']})\n  );\n\n  // Enable Express' case-sensitive and strict options\n  // (so \"/pets/Fido\", \"/pets/fido\", and \"/pets/fido/\" are all different)\n  app.enable('case sensitive routing');\n  app.enable('strict routing');\n\n  app.use(middleware.metadata());\n  app.use(middleware.files(\n    {\n      // Override the Express App's case-sensitive and strict-routing settings\n      // for the Files middleware.\n      caseSensitive: false,\n      strict: false\n    },\n    {\n      // Serve the Swagger API from \"/swagger/api\" instead of \"/api-docs\"\n      apiPath: '/swagger/api',\n\n      // Disable serving the \"PetStore.yaml\" file\n      rawFilesPath: false\n    }\n  ));\n\n  app.use(middleware.parseRequest(\n    {\n      // Configure the cookie parser to use secure cookies\n      cookie: {\n        secret: 'MySuperSecureSecretKey'\n      },\n\n      // Don't allow JSON content over 100kb (default is 1mb)\n      json: {\n        limit: '100kb'\n      },\n\n      // Change the location for uploaded pet photos (default is the system's temp directory)\n      multipart: {\n        dest: path.join(__dirname, 'photos')\n      }\n    }\n  ));\n\n  // These two middleware don't have any options (yet)\n  app.use(\n    middleware.CORS(),\n    middleware.validateRequest()\n  );\n\n  // Add custom middleware\n  app.patch('/pets/:petName', function(req, res, next) {\n    if (req.body.name !== req.params.petName) {\n      // The pet's name has changed, so change its URL.\n      // Start by deleting the old resource\n      myDB.delete(new Resource(req.path), function(err, pet) {\n        if (pet) {\n          // Merge the new data with the old data\n          pet.merge(req.body);\n        }\n        else {\n          pet = req.body;\n        }\n\n        // Save the pet with the new URL\n        myDB.save(new Resource('/pets', req.body.name, pet), function(err, pet) {\n          // Send the response\n          res.json(pet.data);\n        });\n      });\n    }\n    else {\n      next();\n    }\n  });\n\n  // The mock middleware will use our custom data store,\n  // which we already pre-populated with mock data\n  app.use(middleware.mock(myDB));\n\n  // Add a custom error handler that returns errors as HTML\n  app.use(function(err, req, res, next) {\n    res.status(err.status);\n    res.type('html');\n    res.send(util.format('<html><body><h1>%d Error!</h1><p>%s</p></body></html>', err.status, err.message));\n  });\n\n  app.listen(8000, function() {\n    console.log('The Swagger Pet Store is now running at http://localhost:8000');\n  });\n});\n"}